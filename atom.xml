<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>调律者</title>
  
  
  <link href="http://www.zzmark.top/atom.xml" rel="self"/>
  
  <link href="http://www.zzmark.top/"/>
  <updated>2021-01-12T07:41:23.000Z</updated>
  <id>http://www.zzmark.top/</id>
  
  <author>
    <name>Mark Zhou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Thinkpad E440 白名单</title>
    <link href="http://www.zzmark.top/2021/01/id_3075796319/"/>
    <id>http://www.zzmark.top/2021/01/id_3075796319/</id>
    <published>2021-01-12T07:41:23.000Z</published>
    <updated>2021-01-12T07:41:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文就是与白名单斗争的血泪史</p><p>白名单一共有两种对抗手段</p><ol><li>修改逻辑，废除白名单校验功能，直白的讲，就是有个判断，不让代码执行就ok了</li><li>修改数据库，让自己要换的卡成为bios支持的卡。原本支持三块无线网卡，把其中一个的id替换成新卡的id就行</li></ol><p>我最终使用了第二种 <code>修改数据库</code> 的方案，就是替换已有的硬件id</p><p>目前，网上修改白名单的教程，都太老啦，现在工具链比以前先进了很多(感谢vit9696大神的<a href="https://github.com/LongSoft/UEFITool">LongSoft/UEFITool</a>)</p><p>所以我这里用了新的手段，更简单了</p><ol><li>读取bios</li><li>用 UEFITool 找到目标模块，配合 二进制编辑器(我用的 HxD) 替换某块已存在的网卡</li><li>烧录回去</li></ol><p>但是，因为intel的安全限制，更新bios是有校验的，笔记本无法随便刷 bios，也就是你改完了bios，却没法用原本的软件刷入</p><p>所以，想要修改 bios，需要直接用编程器去烧录 bios 芯片<br><img src="/2021/01/id_3075796319/2.png" alt="淘宝随便搜的，第三个烂大街的，是山寨货，能用但坑不浅，后面会说"></p><p>以下就是翻车全过程</p><ul><li>e440 的 bios 分为两个芯片存放，64MBit的 Bios，32MBit的 EC</li><li>我有编程器，但是个山寨货，满淘宝都是同款山寨，毕竟就只是个SPI串口烧录，没有核心技术。开源的板都抄不明白必须得告别这个行业了。</li><li>山寨烧录器配的烧录软件，也是破解版本，最大的坑点，也是翻大车的理由</li><li>官网的 bios 文件，是 12Mbyte(注意单位，1Mbyte = 8MBit)，我没有分离手段，也就是我只能靠备份来拿原始 bios</li></ul><p>我不太想拆 bios，考虑过 SOP 夹子，但这东西，用过的都知道，十几块的玩意就跟一次性一样，而这个笔记本有俩芯片，</p><p>所以我最终选择了这个东西<br><img src="/2021/01/id_3075796319/3.png" alt="没有考虑尺寸"></p><p>但是买的时候，忘记考虑尺寸，到手发现，根本夹不上去，最后还是上烙铁焊下来</p><p><img src="/2021/01/id_3075796319/4.jpg" alt="准备把EC装回去时的照片"></p><h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><blockquote><p>买编程器的时候，都会有配套的软件，鉴于很多人购买的 CH341A 编程器是山寨产品、软件均是破解来的盗版（正版：skygz.taobao.com）<br>  破解来的软件非常不好用（芯片支持不够、报错闪退等）<br>  所以，强烈建议大家丢弃那个破软件<br>  <img src="/2021/01/id_3075796319/5.png" alt="网上借来的图"><br>  满网都是盗版，各种投毒，支持芯片少之又少。<br>  推荐使用 AsProgrammer，有 dalao的汉化，还有简单的说明：<a href="http://www.smxdiy.com/thread-1195-1-1.html">介绍一款 CH341A 编程/烧录 软件 AsProgrammer 汉化版</a></p></blockquote><p>读取的过程，没啥的。</p><p>我的主板，bios和ec是分成两个芯片的，型号分别为 <code>winbond 25q64fvsig</code> 和 <code>winbond 25q32fvsig</code>，之前已经提到，32MBit的是EC，64MBit的是bios(我怎么知道的？没什么神奇的，翻资料)</p><p>thinkpad 的白名单功能，在EC中，所以需要读取的是 32MBit 的那个。</p><p>软件那边，能识别出芯片，就是没问题，具体的芯片型号可以直接看芯片的丝印</p><blockquote><p>若识别错误，可能是接触不良，去排查线路。</p></blockquote><p>读取过程，一定要多读取几次，不要怕耽误时间。</p><ul><li><p>多次读取后，把每一次的都丢进 <code>文件 crc32</code> 算一下是否一致</p></li><li><p>这个可以随便找在线工具，比如这个 <a href="http://tools.jareye.com/crypto/fileverify.html">文件校验</a></p></li></ul><p>最好是读取三次，都一致就ok，若有不一致的，再读几次，确保大部分都是一致的，那个版本基本不会是损坏的</p><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>网上各种教程会让你使用 PhoenixTool 解包，用xsearch搜索，再修改，然后用工具打包。这一堆操作很容易出问题，所以我用更加便捷的工具来做这个。感谢vit9696</p><p>所需工具，一共两个，</p><ul><li><a href="https://github.com/LongSoft/UEFITool">LongSoft/UEFITool</a></li><li>HxD 或者 winhex</li></ul><p>下载 UEFITool 时，注意版本，带NE的版本只有查看和提取能力，不能替换。我们需要不带NE的完全版本，替换模块</p><p><img src="/2021/01/id_3075796319/6.png" alt="单独打开EC肯定会有警告，无视就好"></p><p>首先掌握一个基本技能，就是转换硬件id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 参考网卡，rtl8723be 到设备管理器中寻找。没有留图</span><br><span class="line">PCI\VEN_10EC&amp;DEV_B723&amp;SUBSYS_B72817AA&amp;REV_00</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 提取每一部分，然后丢弃 REV (似乎这个不能丢弃，硬件id中有 REV01可能需要保留，但大部分都没有，起码我这个没有)</span><br><span class="line">10EC B723 B72817AA 00</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 反写</span><br><span class="line">EC10 23B7 AA1728B7</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 去掉空格，这就是最终结果，ec中存放的数据都是这个</span><br><span class="line">EC1023B7AA1728B7</span><br></pre></td></tr></table></figure><ol><li><p>定位要提取的模块<br>白名单中肯定包含当前的卡<br>搜索 Hex Pattern: header and body:  <code>EC1023B7AA1728B7</code><br><img src="/2021/01/id_3075796319/7.png" alt="header and body"><br>当然，搜索 Text : <code>Unauthorized network card is plugged</code> 记得区分大小写，这句话来源于触发白名单时，屏幕上的提示</p></li><li><p>提取模块<br>双击搜索结果，就能定位到我们要找的地方。<br><img src="/2021/01/id_3075796319/9.png" alt="LenovoWmaPolicyDxe"><br>右键 <code>Extract body</code> 提取出这个部分即可<br>如果点击下面那一行的 User interface，可以在右侧看到 <code>Text: LenovoWmaPolicyDxe</code>，就是这个模块的名字</p></li></ol><h2 id="修改白名单"><a href="#修改白名单" class="headerlink" title="修改白名单"></a>修改白名单</h2><p>这里采用了替换法，找一个替死鬼换掉即可</p><p>用二进制编辑工具，打开提取出的模块</p><p>搜索 <code>EC1023B7AA1728B7</code>，能看到三个网卡的硬件id<br><img src="/2021/01/id_3075796319/10.png" alt="三个硬件id"></p><p>选择其中一个做替死鬼，将新网卡的id写入即可</p><p>保存，然后使用 UEFITool 替换刚刚提取的那个模块</p><p><code>右键-Replace Body</code></p><p>然后保存，保存的结果就是修改好的 EC</p><p><img src="/2021/01/id_3075796319/20.jpg" alt="杂乱的笔记"></p><h2 id="烧录回去"><a href="#烧录回去" class="headerlink" title="烧录回去"></a>烧录回去</h2><p>将修改好的EC，刷回去，就行了</p><h2 id="翻车记录"><a href="#翻车记录" class="headerlink" title="翻车记录"></a>翻车记录</h2><p>我翻车的理由，要怪那个山寨的破解软件，不支持我的芯片，我还没有注意到</p><p>结果我修改了一个损坏的 EC，刷回去时也是损坏的。</p><p>最终，只能淘宝买一份原始 Bios，重新修改，两个都拆下来，两个都刷到原始版本，最终解决了问题</p><p>痛恨这傻逼的软件</p><h2 id="另一种尝试"><a href="#另一种尝试" class="headerlink" title="另一种尝试"></a>另一种尝试</h2><p>其实，我还做了另一种尝试，虽然只走到了一半。</p><p>这个尝试极其复杂，外行止步</p><p>首先，额外需要的软件有</p><ul><li>IDA Pro 用于反汇编，若要更好的分析流程，最好找个破解版，带 decompiler 反编译器的</li></ul><p>其次，需要一个常识</p><ul><li>这种涉及到偏移量的汇编，不要妄图增加一个赋值操作，或者删除某些代码，那需要重编译，否则容易导致破坏原有的执行，反而出现bug</li></ul><p>思路就是，找到关键代码，桥接掉</p><p>顺着 <code>Unauthorized network card is plugged</code> 开始查找，可以找到以下函数 <code>sub_690</code></p><p><img src="/2021/01/id_3075796319/11.jpg" alt="目标方法"></p><p>这段代码决定了打印错误内容</p><p>通过 IDA 找到哪里调用了这个函数<br><img src="/2021/01/id_3075796319/12.jpg" alt="目标方法"></p><p>图中的 <code>while(1) ;</code>，就是祸首</p><p>找到对应的汇编</p><p><img src="/2021/01/id_3075796319/13.jpg" alt="目标方法"></p><p>然后，就是如何跳转到正确的位置</p><p>需要修改的时 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loc_826:</span><br><span class="line">...</span><br><span class="line">call  sub_690 &#x2F;&#x2F; 从这里开始，让代码跳转到下边的 loc_845</span><br></pre></td></tr></table></figure><p>可惜，我专业能力不足，不晓得怎么跳转……</p><p>毕竟我一点汇编都没学过……</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>资源下载</p><ul><li><a href="http://www.smxdiy.com/thread-1195-1-1.html">介绍一款 CH341A 编程/烧录 软件 AsProgrammer 汉化版</a></li><li><a href="https://github.com/LongSoft/UEFITool">LongSoft/UEFITool</a></li><li>Hxd</li><li>e440 (型号: 20c5 ver: 2.22 board: nw-151a) 工厂 Bios</li></ul><p>其余的稍后补充</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文就是与白名单斗争的血泪史&lt;/p&gt;
&lt;p&gt;白名单一共有两种对抗手段&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;修改逻辑，废除白名单校验功能，直白的讲，就是有个判断，不让代码执行就ok了&lt;/li&gt;
&lt;li&gt;修改数据库，让自己要换的卡成为bios支持的卡。原本支持三块无线网卡，把其中一个的i</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Thinkpad E440 升级记录</title>
    <link href="http://www.zzmark.top/2021/01/id_3598269465/"/>
    <id>http://www.zzmark.top/2021/01/id_3598269465/</id>
    <published>2021-01-09T09:03:23.000Z</published>
    <updated>2021-01-09T09:03:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>陪伴了我6年的笔记本，折腾了这么久，整理一下笔记</p><h2 id="before"><a href="#before" class="headerlink" title="before"></a>before</h2><p>这笔记本，也算是被我拉到一定高度了，能升级的各种升级，能拉到顶的基本都往顶上拉</p><p>联想的老本子(16年前的型号)大多数都有 pcie 白名单，也就是没法随心所欲换无线网卡</p><p>原本配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CPU: i5 4200m(双核四线程 2.5GHz&#x2F;3.1G TDP 37W)</span><br><span class="line">显卡: Nvidia Geforce GT840M 总之够弱</span><br><span class="line">内存: 4G ddr3 1600</span><br><span class="line">硬盘: WD 500g 5400rpm 7mm 薄盘</span><br><span class="line">屏幕: 1366 x 768 京东方辣眼屏幕(不是诋毁京东方，只是这块屏太低端了)</span><br><span class="line">有线网卡: RTL8111 后边啥忘了，普通的千兆卡</span><br><span class="line">无线网卡: RTL8723BE, wifi单2.4g 300m，蓝牙4.0，双天线，mpcie</span><br></pre></td></tr></table></figure><h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>升级过后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CPU: i7 4710mq(四核八线程 2.5GHz&#x2F;3.5G TDP 47W)</span><br><span class="line">显卡: Nvidia Geforce GT840M 显卡我也换不了</span><br><span class="line">内存: 8G ddr3 1600 x2，拉满16g内存</span><br><span class="line">硬盘: 镁光 m550 240g, 老机器剩下的</span><br><span class="line">屏幕: 友达 b140han01.7 1920 x 1080 ips 就是薄了点，孔位不对，上了胶水</span><br><span class="line">有线网卡: RTL8111 后边啥忘了，普通的千兆卡</span><br><span class="line">无线网卡: intel 7260ac, wifi 双频 300&#x2F;867，蓝牙4.0，双天线，mpcie，不支持mu-mimo，除了魔改安装白果原装卡之外最高的型号了</span><br></pre></td></tr></table></figure><h3 id="屏幕"><a href="#屏幕" class="headerlink" title="屏幕"></a>屏幕</h3><p>屏幕升级是16年的事，只记得原装屏幕和这个差了0.5mm厚度，所以屏幕有缝隙；下边孔位对不上，最后拿胶水粘上的。<br>总之最终效果很好</p><p>笔记本换屏幕，确保接口一致，电压一致，就ok。当然记得注意接口带宽够不够。比如朋友的 dell 灵越7537 768p的就没法直接换1080p，需要补主板上的零件</p><p>附上辣鸡原装屏淘宝的价格(16年换屏幕时候，原装屏80块就能收到)<br><img src="/2021/01/id_3598269465/1.png" alt="如今这破屏幕也贵了不少"></p><h3 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h3><p>这一代笔记本可以换cpu，有几个可选的目标，</p><ul><li>qdet，不显ES，应该只有一两百块，有赌的成分，性能基本等同于 4700mq</li><li>i7 4700mq/4710mq，两者区别不大，价格也是</li><li>i7 4800mq，太热，必须关掉超线程才能快乐玩耍</li><li>i7 4770hq PGA转接，性能比4800mq强一丢丢，核显是 irs 5200，虽然没啥大用。现在不好买到了</li></ul><p>当然，4700mq，性能也就只有 amd ryzen r5 4600u 的一半。感慨时代变迁啊<br>(不过人家6c12t，咱4c8t，差这么多年，输了不丢人)</p><blockquote><p> 先纠正一个点，TDP不是功耗<br>   intel 的解释 <a href="https://www.intel.cn/content/www/cn/zh/support/articles/000055611/processors.html">英特尔®处理器中的散热设计功耗（TDP）</a>。<br>   <a href="https://www.zhihu.com/question/22052609/answer/252695598">TDP能否看作CPU与GPU的额定功率? - 黎小白的回答 - 知乎</a></p></blockquote><h3 id="无线网卡"><a href="#无线网卡" class="headerlink" title="无线网卡"></a>无线网卡</h3><p>白名单内只支持三个卡<br>e440 20c5 一共支持三块无线网卡，分别是 </p><ul><li>rtl8723be</li><li>intel n-7260(单频版本)</li><li>intel 7260ac(官方文档说支持，但bios里的硬件id还是单频的版本，不晓得官方说的是哪个型号)</li></ul><p>以下内容均基于修改白名单。</p><p>可选项其实没几个，因为 minipcie 实在是没啥新卡了</p><p>不外乎两个思路，转接/不转接</p><p>e440 无线网卡仓位，是标准的半高 mini-pcie 27mm x 30mm ，单侧螺丝柱，垂直方面还是有不少余地，可以大胆上转接卡，不会被厚度限制</p><p>长度其实也很足够，能塞下全高 mini-pcie 27mm x 51mm 的仓位，若是转接卡没有留半高的螺丝孔位，也可以自己拿胶水粘上，不会出问题(当然，胶水要靠谱才行)</p><p>转接的话，必然是 mini-pcie to ngff(m.2)，可选卡就挺多了。几个个人推荐</p><ul><li>intel ax210 100块 (最新卡，特性很全，支持wifi6e，蓝牙5.2，需要重新拉天线，自带天线没法跑6G)</li><li>intel ax200 60块 (intel 比 ax210 旧一代的卡，wifi6，蓝牙5.1，也算是笔记本能用最好程度)</li><li>博通 BCM943602BAED，戴尔的 DW1830，天价，没啥意思</li></ul><p>m2 无线网卡一般的尺寸都是 2230，用转接卡肯定要长于原本的长度，若是转接卡没有留螺丝孔，那就</p><p>还有白果原装卡，需要特制的转接卡(毕竟接口不同)，驱动找 bootcamp 中提取，就像是白果装 win 那样</p><ul><li>bcm943602CS 大概要200块。15年的卡，450/1300，蓝牙4.1，(我刚知道这卡的时候，60块就能拿到……)</li><li>bcm94360cd，最高规格(大概)的卡，13年的老卡，四天线卡(3t3r，蓝牙单独一根)，蓝牙4.0，不推荐使用<ul><li>(450/1300)，容易遇到魔改版本 2.4g 600m的怪胎</li></ul></li><li>bcm94360cs2，这是老卡，不推荐，也不便宜</li><li>BCM94360CSAX，也是老卡，不推荐，也贵得要死</li></ul><p>若是非转接，那就只有两种选择了</p><ul><li>intel 7260ac，50块 wifi 双频 300/867，蓝牙4.0，双天线，不支持mu-mimo</li><li>博通 bcm94352z，贵</li><li>博通 bcm94360hmb 三天线卡，贵得很</li><li>高通的卡，我不了解</li></ul><p>我对苹果的无线算是很了解，但出于成本和复杂度，我最终选择了 7260ac，毕竟折腾 ax200 也没啥意思，转接卡也要三四十块</p><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><ul><li><p>我还考虑要改散热，现在的u还是太热了，或许我也可以考虑关掉超线程。</p></li><li><p>也在考虑是否能加上个 wwan 卡，目前还在调查中</p></li><li><p>电池其实也不太行了，损耗达到了50%，不过用的也很少，可能短期内不考虑这个了</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;陪伴了我6年的笔记本，折腾了这么久，整理一下笔记&lt;/p&gt;
&lt;h2 id=&quot;before&quot;&gt;&lt;a href=&quot;#before&quot; class=&quot;headerlink&quot; title=&quot;before&quot;&gt;&lt;/a&gt;before&lt;/h2&gt;&lt;p&gt;这笔记本，也算是被我拉到一定高度了，能升级的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Windows-系统规划、系统重装、系统优化</title>
    <link href="http://www.zzmark.top/2021/01/windows-planning-and-install/"/>
    <id>http://www.zzmark.top/2021/01/windows-planning-and-install/</id>
    <published>2021-01-07T05:52:01.000Z</published>
    <updated>2021-01-07T05:52:01.000Z</updated>
    
    <content type="html"><![CDATA[<style>.content h2, .content h3, .content h4, .content h5 {  color: #3273dc}</style><blockquote><p>本文写自 2020-12-28 日，后半的内容都是在讲故事，重点都在前面<br>  里面的图不是同一台电脑截出来的，不要挑刺</p></blockquote><p>文字极多，我不太会做教程那种啰嗦东西，随便看吧</p><p>想到什么，我会慢慢往上更新</p><hr><p>如今已经 2020 年了，坚持 xp 天下第一的，建议你去看看医生，让医生纠正一下你的 xp 系统</p><p>坚持 win7 天下第一的，如果能说出三个你日常使用下 win7 能做，win10 不能做的东西，那么只有两种情况</p><ol><li>你的使用场景真的离不开 win7</li><li>你对系统的理解已经超越了我</li></ol><p>以上两种，我都建议右上角关闭这个页面，不要浪费彼此的时间</p><p>以下内容，全都是基于 <code>GPT分区</code> <code>UEFI引导</code> <code>windows 10</code> <code>非LSTC版本</code>，如果你不知道其中的是啥，可以无视，确保你的电脑是2012年(intel 初代i3/i5/i7, amd AM3插槽)后出产的型号就行</p><h2 id="before"><a href="#before" class="headerlink" title="before"></a>before</h2><ul><li>下文中出现的 C 盘，一律是系统盘的意思，怕有些人脑子转不过来</li><li>下文提到的 chrome，要么指代 <code>Google Chrome 浏览器</code>，要么指代 <code>开源的 Chromium 内核</code>，因为很多情况把 <code>Chromium 内核</code>叫成 <code>chrome 内核</code>也没什么问题，所以自行判断</li></ul><h2 id="辟谣"><a href="#辟谣" class="headerlink" title="辟谣"></a>辟谣</h2><blockquote><p>如今互联网十分发达，获取知识的成本也变得低廉。<br>  但验证言论的成本越发变高，所以谣言总使比真话传得更快更广，更深得人心</p></blockquote><p>每次看到网上传播的那些个谣言，总让人想到这句话</p><blockquote><p>您还在用番茄花园吗，2020年了，不是2002年</p></blockquote><p>让我们辟几个谣，贴上了目前能想到的几点。</p><p>以下几点，都是错的</p><ol><li><p>软件不能装 C 盘，系统会变慢</p><blockquote><p>软件装在哪里，速度都是一样的，速度不一样，只可能是你的硬盘有问题</p></blockquote></li><li><p>软件装 C 盘太占地方，C 盘空间宝贵</p><blockquote><p>用得多的人都知道，真正占地方的东西，都是些用户数据、缓存、临时文件，就算安装到其他盘，该占 C 盘的，还是占 C 盘</p></blockquote></li><li><p>装系统时候，要分 CDEF 四个区，系统，软件，游戏，文档要分开放，玩游戏把硬盘弄坏了另外两个分区也不会受损</p><blockquote><p>真要是硬盘弄坏了，只可能整个硬盘都挂掉，管你什么CDEFG分区都会死</p></blockquote></li><li><p>不装杀毒软件，就该中病毒了；不装安全软件，就不安全了</p><blockquote><p>不安装杀毒软件，确实风险挺大，但现在 win10 送的杀毒很猛，完全不用操心。<br> 当然，防君子不防小人，你直接给了某个恶意软件超高的权限，还是会死<br> 就算防了小人，也防不住手欠的，你自己关掉了各种更新，遇到漏洞入侵然后说不安全，我该说些什么</p></blockquote></li><li><p>你这 Chrome 是美国的，不安全，咱们中国人得用中国的产品</p><blockquote>国产……十年前国产车还是低端的代名词。国产浏览器，内核都是 chrome 的，美国心，只是有一个国产皮肤罢了<p>= 某60安全浏览器，把本应有的功能包装成会员专享，实在是软件工程的典范</p><p>= 18年国产自主研发，红芯浏览器，被爆出 chrome 换皮</p><p>= <a src="https://www.zhihu.com/question/290564335/answer/472165753">[自主研发一款浏览器内核的难度到底有多大？ - 罗志宇的回答 - 知乎]</a></p></blockquote></li><li><p>自动更新总是让我电脑关不了机/总使提示我重启/更新后游戏就没法玩了/每次都更新失败，开着也没用</p><blockquote><p>面对这种人，只能说微软实在太好心了，老掉牙的危险版本依然能让你用，<br> 你看看 iOS，看看 Mac X OS，强制更新，不更新用个鸡儿，新软件全都不让安装<br> 您信任那些安全软件的漏洞修复，却不信任最了解这系统的人给你提供的安全更新，<br> 如果您对操作系统的理解远超微软，您可以给微软发个邮件，探讨一下系统更新应不应该从 windows 去掉</p></blockquote></li></ol><h2 id="系统规划"><a href="#系统规划" class="headerlink" title="系统规划"></a>系统规划</h2><p>对于系统的规划，主要还是磁盘分区的规划，文件方面的规划，和系统优化方面的内容</p><p>系统优化，先讲讲我对优化这个行为的看法。</p><blockquote>如今个人电脑的性能十分足够，现在的 windows，也没什么值得优化的点了<p>所以我个人是拒绝任何无脑优化的</p><p>当然，针对性的，比如说怎么跑满 100g 网卡，怎么驱动 RDMA，怎么插 4 块 nvme 固态还能跑起来</p><p>但是这些，大家应该都听不懂，说了也没啥意思</p></blockquote><h3 id="分区规划"><a href="#分区规划" class="headerlink" title="分区规划"></a>分区规划</h3><p><img src="/2021/01/windows-planning-and-install/1.png" alt="128固态 + 500g机械，剩余量做了其他用途"></p><p>我个人是不太喜欢分区的，反正分了区，也不会让文件变整洁，还要去区分哪个分区怎么用，想想就头疼。</p><p>但我个人还是拒绝单分区的，推荐将操作系统分离开来。<br>这样重装系统时，可以减少备份的考虑，反正重装了系统，软件也是要重装的，自己的文件绕开C盘就好了</p><p>思路很明确，</p><ul><li>100g~200g 系统分区，有空间就大点给着</li><li>固态有剩余，分配个固态的分区</li><li>剩下的一个分区一块盘</li></ul><p>接下来都是个人见解，大体上区分成了几种情况，思路都是一致的</p><ul><li><p>128g 固态</p><p>就这么点地方，您还是别瞎折腾了</p></li><li><p>128g/256g 固态 + 机械硬盘</p><p>这种场景我的分法是，<br>C(128g 固态), D(机械)</p></li><li><p>512g/1t/2t固态 + 机械硬盘</p><p>C(128g 固态), D(剩余的固态), E(机械)</p></li><li><p>多块固态</p><p>方案1：适合大众。系统盘给操作系统上100~200G，剩下的分给一个分区，其他固态每个固态一个分区</p><p>方案2：跨区卷走起，当然，别存重要资料，小心集体爆炸</p></li></ul><p>说说理由，其实上面都已经说过了</p><ul><li>单纯的 win10 操作系统大概给 100g 以上就差不多够用，也得看软件和其他的数据文件占用多少。虽然经常看到C盘占用率到80%，不过无所谓，煮不在乎。软件多的话就多给一些</li><li>许多软件重装系统也必须重装，所以没必要非得绕开C盘<ul><li>当然，绿色软件可以放到D盘，或者软件十分的多，不想占用宝贵的固态空间，也可以换到其他磁盘上</li></ul></li><li>我的文档、下载、桌面，记得迁移到非C盘（后面有图）</li></ul><h3 id="文件规划"><a href="#文件规划" class="headerlink" title="文件规划"></a>文件规划</h3><blockquote>你们奉为设计的苹果，mac x os，并不存在 CDEF 磁盘分区<p>当然，苹果也没打算让一般用户在机器上安装多块硬盘</p></blockquote><p>磁盘分区规划中已经提到的一点，软件放哪里无所谓，自己用户文件不要乱丢就好。</p><p>如果为了重装系统考虑，把不可再生的用户数据(比如自己做的ppt、照片、word等等)，移出 C 盘</p><p>我个人有整理文件的习惯，自己的文件位置都放的比较规整。</p><p><img src="/2021/01/windows-planning-and-install/5.png" alt="现在一些文件都丢到nas里，这也就比较干净了"></p><p>对于软件产生的文件，我倾向于默认位置，减少各种配置时要考虑的情况，出了问题可参考的内容也多</p><blockquote><p>比如 maven 的仓库，默认就是 <code>~/.m2</code> ，配置文件就在这里<br>qq 的聊天记录，默认放到 <code>文档</code> 中，因为 文档 已经移动到其他分区，也不会无限占用 C 盘空间，重装恢复难度为0<br>软件安装路径，基本都是默认位置，有一些很大的、跟系统无关的，可能会修改个盘符<br>  从 <code>c:\Program Files(x86)\xxxxx</code> 改成 <code>d:\Program Files\xxxxx</code><br>  抹掉 (x86) 这烦人字样，反正 windows 10 没啥必要区分 32位 还是 64位<br>  当然，一些绿色软件，也会放到这里<br>软件的安装包、或者自己的一些免安装小工具，那就指不定在哪了</p></blockquote><p>关于整理文件，分享我自己的整理习惯</p><ul><li>软件安装到 <code>Program Files</code></li><li>用户文件直接迁移到 <code>Users/xxxxxx</code>，保持原有目录结构，就是简单换了个分区</li><li>干活的东西(可能不止一个种类，所以每个种类建议分离开)，找个地方集中放好<ul><li>平常写的工作代码，都在 <code>workspace/&#123;项目名称&#125;/&#123;工程名称&#125;</code></li><li>github 或者一些个人积累代码，都在 <code>github/&#123;项目名称&#125;/&#123;工程名称&#125;</code></li><li>视频处理工程(偶尔还会帮家里人剪个视频)，<code>cut/&#123;日期&#125;/&#123;工程名称&#125;</code></li><li>文档类的，<code>code/&#123;类别&#125;/&#123;啥项目&#125;</code></li></ul></li><li>游戏，<code>Games/&#123;游戏名&#125;</code>，steam：<code>Games/Steam/SteamLibrary</code>，steam本体在c盘默认位置</li><li>照片、截图之类的<ul><li><code>照片/手机照片/&#123;手机型号&#125;/DCIM</code> 型号不同，文件名规则有可能不同。自增的id也可能冲突，所以每个手机单独存放。现在靠nas同步，不用担心同一个手机拍出相同的id了<br><img src="/2021/01/windows-planning-and-install/6.png" alt="没有nas的时候"></li><li><code>照片/手机照片/&#123;日期&#125;/DCIM</code> 没有nas的时候，手动复制，按日期搞就行，冲突自己有办法解决</li><li><code>照片/&#123;相机型号&#125;/&#123;日期&#125;/DCIM</code> 以前还有相机用的时候，也存了一些这样的东西</li></ul></li><li>音乐，迫于网易云全灰，我对云产品的信任真是一天比一天差。所以音频文件都是本地化的<ul><li><code>music/cd/&#123;歌手-专辑名&#125;/xxxxx</code></li><li><code>music/CloudMusic/&#123;歌手&#125;/&#123;专辑&#125;</code></li></ul></li><li>下载的电影、视频、大压缩包 <code>下载/&#123;下载软件&#125;</code> 按软件分开管理，每个下载软件下的东西倾向不同，</li><li><code>系统相关</code><br><img src="/2021/01/windows-planning-and-install/7.png" alt="现在也丢进nas了"></li></ul><p>顺便，送各位一个工具 <a href="http://www.uderzo.it/main_products/space_sniffer/">SpaceSniffer</a>, 可以查看是哪个文件夹占用了您的宝贵硬盘空间</p><p>官网是意大利的，若下载不动，这里有下载好的文件<br><a href="https://download.zzmark.top/SpaceSniffer.exe">我转存的/SpaceSniffer</a></p><h3 id="Windows-推荐配置"><a href="#Windows-推荐配置" class="headerlink" title="Windows 推荐配置"></a>Windows 推荐配置</h3><p>我个人反感魔改系统，所以，这些修改都是遵循 Windows 提供的选项，没有危险操作</p><p>按照推荐程度，从上到下</p><ol><li><p>把 我的文档、桌面、默认下载文件夹，都移动到其他分区上</p><blockquote><p>这样可以将用户常用的位置都迁移到其他地方。不要让 qq 微信 打爆系统盘</p></blockquote><ul><li>打开 <code>计算机(我的电脑)</code>，在左侧找到<code>桌面</code>、<code>文档</code>、<code>下载</code> 等等想要迁移的</li><li>点击右键 - 属性 - 位置选项卡，将路径调整好，我个人倾向于维持原有文件夹名称，迁移到d盘。</li><li>确定即可，会提示是否移动文件</li><li>over<br><img src="/2021/01/windows-planning-and-install/2.png" alt="属性"></li></ul></li><li><p>对于文件管理器，做一些配置。在文件夹选项中</p><blockquote><p>防止最低级的病毒，以及恶意软件</p></blockquote><ul><li>显示隐藏文件，</li><li>隐藏系统文件(推荐)</li><li>显示文件的扩展名</li><li>隐藏文件夹合并通知<br><img src="/2021/01/windows-planning-and-install/3.png" alt="推荐的设置"></li></ul></li><li><p>使用平铺这种布局，更容易一眼找到想要的文件。</p><blockquote><p>还能看到一点缩略图，各方面都很均衡<br> 我个人是不喜欢 windows vista 之后将列表设置为默认的<br> <img src="/2021/01/windows-planning-and-install/8.png" alt="左边详细信息-右边平铺"></p></blockquote></li></ol><ul><li>文件管理器上方 - 查看 - 平铺</li><li>文件管理器上方 - 查看 - 选项 - 查看选项卡 - 应用到文件夹，可以将当前文件夹的布局应用到所有同类文件夹</li></ul><ol><li>合并任务栏，默认情况下会始终合并任务栏，很不直观，个人更倾向于使用 <code>当任务栏已满</code> 这种，能让打开的东西都显示出来。<blockquote><p><img src="/2021/01/windows-planning-and-install/9.png" alt="文件管理器因为太多被折叠了"></p></blockquote><ul><li>具体配置为，任务栏点击右键 - 任务栏设置<br><img src="/2021/01/windows-planning-and-install/4.png" alt="当任务栏已满"></li></ul></li></ol><h2 id="重装系统"><a href="#重装系统" class="headerlink" title="重装系统"></a>重装系统</h2><p>对于磁盘规划，之前也说过，用户数据(文档、下载、桌面) 都不在C盘种，所以我的电脑可以直接抹掉C盘重装系统，丝毫不用犹豫丢了重要文件</p><p>关于安装系统，自从 windows 10 1511 版本以后，MSDN的 iso 内核心的wim文件也超过了 4g，没法直接写iso或者找个u盘随便装，很是麻烦。</p><p>但，微软爸爸提供了更加方便的操作，官方工具，插上u盘直接制作安装盘，一键操作，长手就能用，只需要U盘大小大于8G小于32G(大于32g也有办法，只不过略微麻烦，小白直接无脑16g就好了)</p><p><a href="https://www.microsoft.com/zh-cn/software-download/windows10">下载 Windows 10</a></p><p>安装过程全中文，网页下边还提供了教程，不傻就能看懂。</p><p>不过还是说几句，</p><ul><li><p>新机器安装系统时，建议安装阶段只给一个系统分区，避免不小心把系统装歪了地方</p></li><li><p>老机器重装系统时，用磁盘容量来确认是哪个分区，因为那个界面并没有 CDEFG 之类</p></li></ul><hr><h2 id="闲谈无聊的过去"><a href="#闲谈无聊的过去" class="headerlink" title="闲谈无聊的过去"></a>闲谈无聊的过去</h2><blockquote><p>文章末尾，其实没什么用，讲讲故事了</p></blockquote><p>故事中的那些傻子，肯定不是我。</p><p>我对于装系统这项技能的掌握很早，05年跟着电脑店的师傅学习过，07年自我尝试，09年后半就已经开始用上win7了，那时候还叫开发者预览版（?）</p><p>无师自通，师从外行，都是让人绕弯子的东西，但绕过的弯子，也让我理解了很多基础的东西，虽然现在眼界专业了，看着就跟玩笑一样</p><h3 id="C盘？其他的盘？有什么区别"><a href="#C盘？其他的盘？有什么区别" class="headerlink" title="C盘？其他的盘？有什么区别"></a>C盘？其他的盘？有什么区别</h3><p>以前玩多系统的时候，曾经做过操作系统在 F 盘的情况</p><p>当时身边的人很诧异，就问我，你这C盘咋没了呢</p><p>当时的情况是这样</p><ul><li>分区1 win7(C)</li><li>分区4 win8(F)</li></ul><p>切换系统时，将另一个系统的分区隐藏掉。也就只有 D E F 然后系统 logo 标记在了 F 上</p><p>这是个认知错误，并没有规定系统只能安装到 C，也并没有规定过 C 一定要存在</p><hr><p>当然，这之后，我把 F 改成了 C，情况更有趣了</p><ul><li>分区1 win7(C)</li><li>分区2 (D)</li><li>分区3 (E)</li><li>分区4 win8(C)</li></ul><p>切换系统时，将另一个系统的分区隐藏掉</p><p>有很多人认为，CDEF 就是按照顺序排下来的。实际上，这也只是打了个标签而已，顺序都是随意的</p><p>嗯，当时也是震惊了很多身边半懂不懂的人</p><h3 id="传统引导-UEFI-过渡-时期的混沌"><a href="#传统引导-UEFI-过渡-时期的混沌" class="headerlink" title="传统引导 - UEFI 过渡 时期的混沌"></a>传统引导 - UEFI 过渡 时期的混沌</h3><p>距今最近的混沌时期，就是 传统引导 - UEFI 过渡的那个时期了</p><p>这个过渡期本应是 windows 7 的那个时代，也就是 10 11 12年，在微软的 vista 暴死之后</p><p>但那之后，win7 接手，这个系统过于成功，让那个过渡期并没有什么犹豫，多数人都是选择放弃 UEFI 引导的</p><p>所以这个过渡期被顺延到了 win8 的时代</p><p>首先，win7 可以在 CSM 技术加持下支持 UEFI 引导的，但因激活手段太差(传统引导的 OEM7F7 工具实在是太猛了)，并没有人想用</p><p>而且，UEFI 的 win7 也没什么优势，毕竟那会固态还不普及，开机速度更多还是硬盘限制</p><p>win7 过于成功，现在还存在 win7天下第一的神教，我都怀疑这波人就是当年吹 xp强于win7的那一群</p><p>就因为win7这帮人，到了win8的时代，也就出现了很多麻烦的事情</p><p>比如，自认为有两把刷子的小白给win8重装，还想着老一套 Ghost 还原方案，结果发现无法开机，各种翻车。原因在于 win8 出厂都是 UEFI 引导，有些人查到了百度的二手资料，得知要调整为 Legacy boot，但 Bios 里那一项却不让调整，就说电脑垃圾，win8 垃圾。</p><p>经历坎坷，关掉了 Security boot，后，装上了 win7，然后发现芯片组驱动不起来，usb不好用，声卡没声音，毕竟win8 的驱动没法给 win7 用，而很多笔记本没提供 win7 驱动，几乎是死局</p><p>以前的 PC 有一个叫法，称为 <code>IBM PC 兼容机</code>，现在的 PC 规范由多个公司组织联合制定，硬件型号相同，驱动也有很大程度的通用性。<br>所以这个混沌的年代成功倒退了回去，只要单独安装驱动，就可以让不提供 win7 驱动的 笔记本，安装 win7 操作系统。又不是不能用</p><h3 id="装系统的本质"><a href="#装系统的本质" class="headerlink" title="装系统的本质"></a>装系统的本质</h3><p>这不算是个故事，算是个人理解。</p><p>装系统的本质？</p><ol><li>解压缩</li><li>将解压缩的结果，引导起来</li></ol><p>Over.</p><p>等等，就这？</p><p>没错，就这。</p><h3 id="谈论引导，以及多系统共存"><a href="#谈论引导，以及多系统共存" class="headerlink" title="谈论引导，以及多系统共存"></a>谈论引导，以及多系统共存</h3><p>我对于引导的研究，更多的在于传统引导</p><p>那个年代很纯真，启动盘的活动分区的引导扇区，就那么点容量，读取出来执行代码，来决定如何引导操作系统</p><p>UEFI 其实更简单粗暴，也更灵活了，</p><ul><li>第一个 fat/fat32 分区</li><li>/EFI/BOOT/BOOTX64.efi (不区分大小写)(只是默认情况，实际可以根据主板内写入的引导项指向其他文件)</li></ul><p>.efi 文件就是个可执行的二进制，电脑按照这之中的代码来决定如何引导操作系统</p><p>GPT分区表，并不是必须的</p><p>传统引导扇区，就那么点容量，现在的 efi 文件，一两 mb 都是可以的</p><hr><p>多系统共存，难点其实在于规划，只要让多条引导拉起不同的系统，也就实现了共存。<br>规划要让多个系统的文件分离开，确切说是互相不要产生不可控的影响</p><p>当然，最乱的时候，我的电脑里同时躺着4个系统</p><blockquote><p>win7, xp, ubuntu, mac</p></blockquote><p>ubuntu是干啥的？导出声卡 codec 和 dsdt，以前玩黑果的人都知道</p><hr><p>传统引导的多系统共存，只需要多个主分区即可，当然因为MBR的限制，最多只有四个分区(所有逻辑分区算一个，但逻辑分区无法引导)<br>也就是，单硬盘四个可设置活动分区的主分区，就是极限。当然，正常人谁会用到那么多</p>]]></content>
    
    
      
      
    <summary type="html">&lt;style&gt;
.content h2, .content h3, .content h4, .content h5 {
  color: #3273dc
}
&lt;/style&gt;

&lt;blockquote&gt;
&lt;p&gt;本文写自 2020-12-28 日，后半的内容都是在讲故事，重点都在</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>裸机运维(一)-远程服务器安装</title>
    <link href="http://www.zzmark.top/2020/11/id_2184768189/"/>
    <id>http://www.zzmark.top/2020/11/id_2184768189/</id>
    <published>2020-11-24T07:18:02.000Z</published>
    <updated>2020-11-24T07:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="intro"><a href="#intro" class="headerlink" title="intro"></a>intro</h2><p>裸机运维系列1</p><p>文中提到的工具，在文末有<a href="##Other">下载地址</a></p><p>最近因为点特别情况，需要远程搞几台服务器</p><p>服务器有超微板子的工控机，有 dell r610 和同年代的 r410，反正都挺慢的</p><p>用 IPMI 远程安装系统，也算是裸机运维的第二步。你问第一步是啥？当然是给 IPMI 配地址了啊</p><p><img src="/2020/11/id_2184768189/1.png" alt="超微IPMI的配置，用IPMI连过来不让修改"></p><h2 id="pre"><a href="#pre" class="headerlink" title="pre"></a>pre</h2><h3 id="first"><a href="#first" class="headerlink" title="first"></a>first</h3><p>机器不在本地，远程那边有一个 windows 10 来做工作环境，所以下文本地指代的都是这台 windows 10。</p><p>安装系统的过程，和自己插 U盘 安装完全一致，也就没什么多说的了</p><p>因为网段内，没有啥基础设施，机器也不多，所以 IPMI 手动改<code>静态ip</code>，省心</p><p>dell 可以直接在面板上按，超微工控就得进 bios 了，好在超微板子开机快，并不是太费劲。</p><p>(dell)的机器忘了拍照，感兴趣的自己去玩吧</p><p>dell 的 idrac，一个字，慢，哪方面都是</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>首先，IPMI，需要 java。</p><p>嗯……我这都是老机器，没有 web console 那种先进玩意</p><p>所以，先装一套 java。</p><p>尤其注意，oracle jdk 8。别装错了</p><p>javaws 在这里比较方便用，其他版本，虽然有不少也可以的，不过9之后的版本，安全设置位置不同，得自己找资料</p><p>如果你的机器不是那么野性，可以直接用 OpenWebStart ，可惜 r610 的 idrac 不改 Java 安全文件就起不来，我还是单独装了一套 jdk</p><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><h3 id="粗野的手法"><a href="#粗野的手法" class="headerlink" title="粗野的手法"></a>粗野的手法</h3><p>直接在 ipmi kvm 中挂载 iso 即可，就像是自己插了个u盘上去</p><p>当然，这个方法，有个很傻逼的点，就是速度实在是，太慢啦！</p><p>传输速度仅有 1m。一个 600m 的镜像，要 10 分钟才能启动。</p><h3 id="ipxe-更加高端快速的手段"><a href="#ipxe-更加高端快速的手段" class="headerlink" title="ipxe 更加高端快速的手段"></a>ipxe 更加高端快速的手段</h3><p>本片文章主要记录的就是这部分</p><p>这里不是科普，不是技术探究，也不是什么尖端问题分析。只是记录自己的解法，当作备忘。</p><p>IPMI 直传，慢的原因在于 IPMI。就别想着什么优化了，我这俩机器拿线直接插上，也还是1m，可能这几个机器的 IPMI 就这么设计的吧</p><p>破局的方法是 PXE 网络引导，通过本地搭建 PXE 服务器做引导。解决 IPMI 速度过慢问题。</p><p>我没有测试原生 PXE 咋样，我嫌麻烦，用了比较成品的方案。</p><p>ipxe 可选使用 http 传输，速度嘛，打满了百兆(这几台机器 IPMI 都是百兆网卡)</p><p>我懒得去找台 linux 搭建 ipxe，所以偷懒用了 tiny pxe server。</p><p><img src="/2020/11/id_2184768189/QQ%E6%88%AA%E5%9B%BE20201124171641.png" alt="tiny pxe server界面"></p><p>界面十分简单。有需要详细教程的自行百度。因为我的网卡 pxe 都是跑在 legacy 引导下，所以没法上 uefi</p><p>我的应用场景很简单，拿 PXE 替代引导U盘 就行，把镜像放到指定位置，选好网卡，点击启动就行了。</p><p>程序自带 httpd:80，DHCP 所以当心当前 vlan 内有其他新设备上线，会被分配到 IP 的。</p><p>默认配置文件在 menu.ipex，需要自行改动，语法很简单，找使用了 sanboot 的项目，复制一份改一改就能引导</p><p><img src="/2020/11/id_2184768189/QQ%E6%88%AA%E5%9B%BE20201124172034.png" alt="menu.ipxe"></p><p>顺带一提，网吧的无盘系统，就是用 pxe 启动 iscsi </p><h2 id="更自动化的竞品-netboot-xyz"><a href="#更自动化的竞品-netboot-xyz" class="headerlink" title="更自动化的竞品 netboot.xyz"></a>更自动化的竞品 netboot.xyz</h2><p>只是简单跑了一下，如果我要部署的是 ubuntu，或者 centos，我或许会用这个</p><p>当然，网速够快的话</p><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><h3 id="dell-r610-Connection-Failed"><a href="#dell-r610-Connection-Failed" class="headerlink" title="dell r610 Connection Failed"></a>dell r610 Connection Failed</h3><p>这个问题发生于 idrac 6, java 8+</p><p>官方有过相应报告，有说法是换成 java 1.7 就好，不过我并没有现成的环境</p><p>原因似乎是 idrac6 默认使用的 tls 算法被标记为禁用，所以最后有两种解法</p><ol><li><p>修改 jre 的文件，解除禁用</p><p>需要修改配置文件</p><p>本方法基于 oracle jdk 8，似乎哪个小版本都成</p><p>修改文件 <code>&#123;JRE_HOME&#125;\lib\security\java.security</code></p><p>直接将 jdk.tls.disabledAlgorithms 注释掉</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Algorithm restrictions for Secure Socket Layer/Transport Layer Security</span></span><br><span class="line"><span class="comment"># (SSL/TLS) processing</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In some environments, certain algorithms or key lengths may be undesirable</span></span><br><span class="line"><span class="comment"># when using SSL/TLS.  This section describes the mechanism for disabling</span></span><br><span class="line"><span class="comment"># algorithms during SSL/TLS security parameters negotiation, including</span></span><br><span class="line"><span class="comment"># protocol version negotiation, cipher suites selection, peer authentication</span></span><br><span class="line"><span class="comment"># and key exchange mechanisms.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Disabled algorithms will not be negotiated for SSL/TLS connections, even</span></span><br><span class="line"><span class="comment"># if they are enabled explicitly in an application.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For PKI-based peer authentication and key exchange mechanisms, this list</span></span><br><span class="line"><span class="comment"># of disabled algorithms will also be checked during certification path</span></span><br><span class="line"><span class="comment"># building and validation, including algorithms used in certificates, as</span></span><br><span class="line"><span class="comment"># well as revocation information such as CRLs and signed OCSP Responses.</span></span><br><span class="line"><span class="comment"># This is in addition to the jdk.certpath.disabledAlgorithms property above.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># See the specification of &quot;jdk.certpath.disabledAlgorithms&quot; for the</span></span><br><span class="line"><span class="comment"># syntax of the disabled algorithm string.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># <span class="doctag">Note:</span> The algorithm restrictions do not apply to trust anchors or</span></span><br><span class="line"><span class="comment"># self-signed certificates.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># <span class="doctag">Note:</span> This property is currently used by the JDK Reference implementation.</span></span><br><span class="line"><span class="comment"># It is not guaranteed to be examined and used by other implementations.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Example:</span></span><br><span class="line"><span class="comment">#   jdk.tls.disabledAlgorithms=MD5, SSLv3, DSA, RSA keySize &lt; 2048</span></span><br><span class="line"><span class="comment">#jdk.tls.disabledAlgorithms=SSLv3, RC4, DES, MD5withRSA, DH keySize &lt; 1024, \</span></span><br><span class="line"><span class="comment">#    EC keySize &lt; 224, 3DES_EDE_CBC, anon, NULL, \</span></span><br><span class="line"><span class="comment">#    include jdk.disabled.namedCurves</span></span><br></pre></td></tr></table></figure><p>这个配置是禁止 tls 使用某种算法，注释掉是全部放行，有一定风险，不过 java 8 在我这并不是主用</p><p>也有一个说法，移除掉 SSLv3 和 RC4 就行，让两边使用这些算法</p></li><li><p>直接给 idrac 签个证书</p><p>这个方法是 dell community 中提供的方法，我没有尝试</p></li></ol><h3 id="一些傻逼的情况"><a href="#一些傻逼的情况" class="headerlink" title="一些傻逼的情况"></a>一些傻逼的情况</h3><ul><li><p>dell r610 的 idrac 中，下载 jnlp 文件，后缀名会错，需要手动改……</p></li><li><p>dell r610 的 jnlp 默认文件名极长，用 OpenWebStart 打开会报错。手动删掉一大段就好了。</p></li><li><p>超微的ipmi，kvm中 默认 F2 是退出。esxi 界面上，F2 是设置……<br>就很尴尬，需要在 Options 中改键</p></li><li><p>超微的ipmi，kvm中 esc 也有很恶心的情况，记得改配置的时候，看好了提示框是啥<br>我不小心重启了两次……好在重启很快</p></li><li><p>超微提供了 IPMIView20，好歹能用，但是吧，都 2020 年了，就不能适配一下高DPI吗，我这高分屏看着好难受啊(虽然这锅可能要丢给Java)</p><ul><li>这个 IPMIView 中，不晓得是不是带的 jdk 版本有毛病，kvm 中没法挂载 iso，最后还是得靠 OpenWebStart</li></ul></li><li><p>OpenWebStart，自带了下载 jdk 的功能，可下载的版本实在太新，面对旧设备(dell r610)，居然没法握手。还得手动改 jdk，再靠修改 jdk 中允许使用的安全算法，避让这个东西。傻逼老 dell</p></li><li><p>剩下的不太想得起来，再说了</p></li></ul><h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><p>文中的工具下载地址</p><ul><li><a href="https://openwebstart.com/download/">OpenWebStart</a></li><li><a href="https://www.supermicro.org.cn/SwDownload/SwSelect_Free.aspx?cat=IPMI">IPMIView</a></li><li>pxesrv<ul><li><a href="http://labalec.fr/erwan/?page_id=958">pxesrv作者博客</a></li><li><a href="http://erwan.labalec.fr/tinypxeserver/pxesrv.zip">官方下载地址(很慢)</a></li><li><a href="https://download.zzmark.top/ipmi/pxesrv.zip">我的镜像(08/01/2020)</a></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;intro&quot;&gt;&lt;a href=&quot;#intro&quot; class=&quot;headerlink&quot; title=&quot;intro&quot;&gt;&lt;/a&gt;intro&lt;/h2&gt;&lt;p&gt;裸机运维系列1&lt;/p&gt;
&lt;p&gt;文中提到的工具，在文末有&lt;a href=&quot;##Other&quot;&gt;下载地址&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>gitlab升级记录</title>
    <link href="http://www.zzmark.top/2020/11/id_983467528/"/>
    <id>http://www.zzmark.top/2020/11/id_983467528/</id>
    <published>2020-11-06T04:01:02.000Z</published>
    <updated>2020-11-23T10:16:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>公司用的版本是 8.17.4 ，研发部门用不惯，恰好内网服务器重新部署，决定升级</p><p>本文中，所有版本号均为编写时的版本参考，必要的地方贴了地址，记得去看新的文档</p><p>本文撰写时，最新版本为 13.5.1，封面截图时最新版本已经是13.6.0，由于没有升级计划，所以并没有使用最新的图</p><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>首先，备份，并把备份文件拖回本地</p><ul><li><p>备份本体</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-rake gitlab:backup:create</span><br></pre></td></tr></table></figure><p>默认情况下，备份结果会在 /var/opt/gitlab/backups</p></li><li><p>将配置文件进行备份</p><ul><li>/etc/gitlab/gitlab.rb 配置文件</li><li>/var/opt/gitlab/nginx/conf nginx配置文件</li><li>/etc/postfix/main.cfpostfix 邮件配置备份(可选)</li><li>/etc/gitlab/gitlab-secrets.json 密钥文件，里面有数据库的密码</li></ul></li></ul><h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><p>gitlab 要按照版本逐个升级，官方给出了<a href="https://docs.gitlab.com/13.5/ee/policy/maintenance.html#example-upgrade-paths">升级路线</a>，</p><p>大概意思就是，跨版本升级，要升级到当前主要版本最新的版本，才能跨入下一个版本</p><p>我们的版本是 8.17.4，最终的升级路线为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8.17.4 -&gt; 8.17.7 -&gt; 9.5.10 -&gt; 10.8.7 -&gt; 11.3.4 -&gt; 11.11.8 -&gt; 12.0.12 -&gt; 12.10.14 -&gt; 13.0.14 -&gt; 13.5.1(当前最新)</span><br></pre></td></tr></table></figure><p>极其漫长……</p><h3 id="pre"><a href="#pre" class="headerlink" title="pre"></a>pre</h3><p>首先一个误区，升级不能关闭 gitlab</p><p>如果以前改动过某些配置文件，中间可能会有询问，所以盯着点</p><p>执行 upgrade 时，系统的部分也会升级，如果用的系统已经不在维护期内，比如ubuntu 1710(我们就是这傻逼东西)，最好先解决系统问题</p><p>我的做法是，拉个新虚拟机，ubuntu 1604 lts(截止到2021年4月)，不选1804纯是因为手上只有这现成的，之后会考虑迁移到 centos7.8(EOL 2024年6月)</p><p>记得替换源（我用的是 清华）</p><p>执行命令时，最好给 ssh 工具开个日志记录，我用的 xshell，记录下过程中的日志，避免出了问题不好排查</p><h3 id="各路升级命令"><a href="#各路升级命令" class="headerlink" title="各路升级命令"></a>各路升级命令</h3><p>很复制粘贴，直接升级上来就行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get upgrade gitlab-ce=8.17.7-ce.0</span><br><span class="line">sudo apt-get upgrade gitlab-ce=9.5.10-ce.0</span><br><span class="line">sudo apt-get upgrade gitlab-ce=10.8.7-ce.0</span><br><span class="line">sudo apt-get upgrade gitlab-ce=11.3.4-ce.0</span><br><span class="line">sudo apt-get upgrade gitlab-ce=11.11.8-ce.0</span><br><span class="line">sudo apt-get upgrade gitlab-ce=12.0.12-ce.0</span><br><span class="line">sudo apt-get upgrade gitlab-ce=12.10.14-ce.0</span><br><span class="line">sudo apt-get upgrade gitlab-ce=13.0.14-ce.0</span><br><span class="line">sudo apt-get upgrade gitlab-ce=13.5.1-ce.0</span><br></pre></td></tr></table></figure><p>感谢多年前部署该系统的人，没有给我留什么配置文件上的大坑</p><h2 id="迁移到docker中"><a href="#迁移到docker中" class="headerlink" title="迁移到docker中"></a>迁移到docker中</h2><p>为了方便日后维护，新开了个靠谱的虚拟机，专门用于 gitlab (以前的gitlab连raid都没有)。</p><p>迁移过程如下</p><p>配置块存储、mount、fstab、docker/daemon.json、net优化，宿主机该做的都做完后，用 docker-compose 启动 gitlab</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.7&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">gitlab/gitlab-ce:13.5.1-ce.0</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">&#x27;gitlab.vajra.ltd&#x27;</span></span><br><span class="line">    <span class="attr">shm_size:</span> <span class="string">256M</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">GITLAB_OMNIBUS_CONFIG:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">external_url</span> <span class="string">&#x27;http://gitlab.vajra.ltd&#x27;</span><span class="string">;</span></span><br><span class="line">        <span class="string">gitlab_rails[&#x27;gitlab_default_projects_features_builds&#x27;]</span> <span class="string">=</span> <span class="literal">false</span><span class="string">;</span></span><br><span class="line">        <span class="string">gitlab_rails[&#x27;lfs_enabled&#x27;]</span> <span class="string">=</span> <span class="literal">true</span><span class="string">;</span></span><br><span class="line">        <span class="string">nginx[&#x27;custom_gitlab_server_config&#x27;]</span> <span class="string">=</span> <span class="string">&quot;location /-/plantuml/ &#123; \n    proxy_cache off; \n    proxy_pass  http://plantuml:8080/; \n&#125;\n&quot;</span><span class="string">;</span></span><br><span class="line">        <span class="string">gitlab_rails[&#x27;ldap_enabled&#x27;]</span> <span class="string">=</span> <span class="literal">true</span><span class="string">;</span></span><br><span class="line">        <span class="string">gitlab_rails[&#x27;prevent_ldap_sign_in&#x27;]</span> <span class="string">=</span> <span class="literal">false</span><span class="string">;</span></span><br><span class="line">        <span class="string">gitlab_rails[&#x27;ldap_servers&#x27;]</span> <span class="string">=</span> &#123;</span><br><span class="line">          <span class="string">&#x27;main&#x27;</span> <span class="string">=&gt;</span> &#123;</span><br><span class="line">            <span class="string">&#x27;label&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;LDAP&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;host&#x27;</span> <span class="string">=&gt;</span>  <span class="string">&#x27;ldap.vajra.ltd&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;port&#x27;</span> <span class="string">=&gt;</span> <span class="number">389</span>,</span><br><span class="line">            <span class="string">&#x27;uid&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;uid&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;encryption&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;plain&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;bind_dn&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;cn=admin,dc=vajra,dc=ltd&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;password&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;timeout&#x27;</span> <span class="string">=&gt;</span> <span class="number">10</span>,</span><br><span class="line">            <span class="string">&#x27;active_directory&#x27;</span> <span class="string">=&gt;</span> <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&#x27;allow_username_or_email_login&#x27;</span> <span class="string">=&gt;</span> <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&#x27;block_auto_created_users&#x27;</span> <span class="string">=&gt;</span> <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&#x27;base&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;ou=Users,dc=vajra,dc=ltd&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;attributes&#x27;</span> <span class="string">=&gt;</span> &#123;</span><br><span class="line">              <span class="string">&#x27;username&#x27;</span> <span class="string">=&gt;</span> [<span class="string">&#x27;uid&#x27;</span>, <span class="string">&#x27;userid&#x27;</span>, <span class="string">&#x27;sAMAccountName&#x27;</span>],</span><br><span class="line">              <span class="string">&#x27;email&#x27;</span> <span class="string">=&gt;</span> [<span class="string">&#x27;mail&#x27;</span>, <span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;userPrincipalName&#x27;</span>],</span><br><span class="line">              <span class="string">&#x27;name&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;cn&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;first_name&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;givenName&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;last_name&#x27;</span> <span class="string">=&gt;</span> <span class="string">&#x27;sn&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&#x27;lowercase_usernames&#x27;</span> <span class="string">=&gt;</span> <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;80:80&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;443:443&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;22:22&#x27;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;/data/gitlab/config:/etc/gitlab&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;/data/gitlab/logs:/var/log/gitlab&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;/data/gitlab/data:/var/opt/gitlab&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">plantuml:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&#x27;plantuml/plantuml-server:jetty&#x27;</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">plantuml</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure><p>docker中安装相同版本，然后按照传统步骤执行。</p><ol><li>先确保 gitlab-secrets.json 一致</li><li>将备份文件复制到 docker 容器的映射目录中</li><li>修复权限(因为是直接目录挂载到了容器内，没有用 volume，为的是日后提取东西方便，虽然这样也脆弱了很多)</li></ol><p>参考 <a href="https://docs.gitlab.com/ee/raketasks/backup_restore.html#restore-for-docker-image-and-gitlab-helm-chart-installations">官方文档-docker恢复步骤</a>，按步骤执行即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker <span class="built_in">exec</span> -it xxxxx bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止相关服务</span></span><br><span class="line">$ gitlab-ctl stop unicorn</span><br><span class="line">$ gitlab-ctl stop puma</span><br><span class="line">$ gitlab-ctl stop sidekiq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查状态</span></span><br><span class="line">$ gitlab-ctl status</span><br><span class="line">run: alertmanager: (pid 1001) 1719s; run: <span class="built_in">log</span>: (pid 695) 1765s</span><br><span class="line">run: gitaly: (pid 1021) 1718s; run: <span class="built_in">log</span>: (pid 301) 1898s</span><br><span class="line">run: gitlab-exporter: (pid 626) 1787s; run: <span class="built_in">log</span>: (pid 640) 1783s</span><br><span class="line">run: gitlab-workhorse: (pid 966) 1720s; run: <span class="built_in">log</span>: (pid 588) 1802s</span><br><span class="line">run: grafana: (pid 1029) 1718s; run: <span class="built_in">log</span>: (pid 745) 1755s</span><br><span class="line">run: logrotate: (pid 609) 1793s; run: <span class="built_in">log</span>: (pid 621) 1789s</span><br><span class="line">run: nginx: (pid 591) 1799s; run: <span class="built_in">log</span>: (pid 602) 1795s</span><br><span class="line">run: postgres-exporter: (pid 1010) 1718s; run: <span class="built_in">log</span>: (pid 719) 1761s</span><br><span class="line">run: postgresql: (pid 392) 1893s; run: <span class="built_in">log</span>: (pid 478) 1891s</span><br><span class="line">run: prometheus: (pid 983) 1719s; run: <span class="built_in">log</span>: (pid 678) 1771s</span><br><span class="line">down: puma: 11s, normally up; run: <span class="built_in">log</span>: (pid 528) 1814s</span><br><span class="line">run: redis: (pid 258) 1905s; run: <span class="built_in">log</span>: (pid 265) 1904s</span><br><span class="line">run: redis-exporter: (pid 976) 1720s; run: <span class="built_in">log</span>: (pid 659) 1777s</span><br><span class="line">down: sidekiq: 4s, normally up; run: <span class="built_in">log</span>: (pid 553) 1808s</span><br><span class="line">run: sshd: (pid 27) 1925s; run: <span class="built_in">log</span>: (pid 26) 1925s</span><br><span class="line"></span><br><span class="line">$ gitlab-backup restore BACKUP=1604455708_2020_11_04_13.5.1</span><br></pre></td></tr></table></figure><p>完成上述动作后，重启容器，等待服务正常运转后，执行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Check GitLab</span></span><br><span class="line">docker <span class="built_in">exec</span> -it &lt;name of container&gt; gitlab-rake gitlab:check SANITIZE=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>完全通过后，迁移完成，后续升级按照 <a href="https://docs.gitlab.com/omnibus/docker/README.html#update">docker 升级流程</a>，就是按照版本，直接删掉旧容器，换成新的启动，即可</p><p>gitlab 配置了 LDAP，这部分之后新开文章记录</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>整合后，途中断过一次电，发现 docker 容器整个都丢了……</p><p>虽然不晓得怎么回事，不过好在恢复起来不是太难，重新创建一个容器就好了</p><p>但创建容器后，并没有启动，查询日志发现，容器出现了几个问题</p><h3 id="权限问题-Permission-Denied"><a href="#权限问题-Permission-Denied" class="headerlink" title="权限问题 Permission Denied"></a>权限问题 <code>Permission Denied</code></h3><p>很容易解决</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it gitlab update-permissions</span><br></pre></td></tr></table></figure><h3 id="Redis-RDB-无法读取"><a href="#Redis-RDB-无法读取" class="headerlink" title="Redis RDB 无法读取"></a>Redis RDB 无法读取</h3><p>具体日志忘了存留<br>解决方法也很简单，摸到 redis 日志位置，直接删掉，收工，连容器都不用重启</p><h3 id="alertmanager-unexpected-EOF"><a href="#alertmanager-unexpected-EOF" class="headerlink" title="alertmanager unexpected EOF"></a>alertmanager unexpected EOF</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">caller&#x3D;main.go:261 err&#x3D;&quot;unexpected EOF&quot;</span><br></pre></td></tr></table></figure><p>解法同上，摸过去删掉，反正 alertmanager 的存储只有告警历史和 since 配置，这些都可以重来</p><p>gitlab 的容器十分完备，连 <code>ps aux | grep alertmanager</code> 这命令都能执行，追查起来和宿主机一样</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;公司用的版本是 8.17.4 ，研发部门用不惯，恰好内网服务器重新部署，决定升级&lt;/p&gt;
&lt;p&gt;本文中，所有版本号均为编写时的版本参考，必要的地方贴了地址，记得去看新的文档&lt;/p&gt;
&lt;p&gt;本文撰写时，最新版本为 13.5.1，封面截图时最新版本已经是13.6.0，由于没有升</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>i18n-Accept-Language相关研究</title>
    <link href="http://www.zzmark.top/2020/09/id_2756259807/"/>
    <id>http://www.zzmark.top/2020/09/id_2756259807/</id>
    <published>2020-09-22T16:00:00.000Z</published>
    <updated>2020-09-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>网页端 i18n 必然会涉及到的 header 就是 Accept-Language</p><p>相关内容可以直接参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Language">MDN Accept-Language</a></p><p>不过这个字段对于中文，有许多历史遗留问题，这里只讲最终结论</p><p>关于 Accept-Language 以及各种操作系统 lang 的取值，遵守的标准是 <a href="https://tools.ietf.org/html/bcp47">ieft-BCP47 Tags for Identifying Languages</a></p><h2 id="zh-zh-CN-zh-Hans-zh-Hant-之间的关系"><a href="#zh-zh-CN-zh-Hans-zh-Hant-之间的关系" class="headerlink" title="zh, zh-CN, zh-Hans, zh-Hant 之间的关系"></a>zh, zh-CN, zh-Hans, zh-Hant 之间的关系</h2><p>如果你的系统语言环境是 <code>简体中文</code>，那么 chrome 浏览器会默认将 Accept-Language 填写为 <code>zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,zh-HK;q=0.6</code></p><p><img src="/2020/09/id_2756259807/0.png" alt="Chrome 请求 Header"></p><p>这其中有很多有趣的点可以解读</p><p>首先，<code>zh-CH,zh;q=0.9</code>，这其实是两部分，写完整的话应该是 <code>zh-CH;q=1.0,zh;q=0.9</code> 用q做了一个优先度</p><p>但这俩都是中文，目前大多数的服务端，都会将 zh-CN 当作 <code>简体中文</code>，但实际上并不正确，这就是历史遗留问题<br>第二种 zh 实际上也是废弃标准，但绝大多数服务端，都没有舍弃这两种废弃标准的使用。</p><p>类似的还有很多，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zh-Hans, zh-Hans-CN, zh-cmn, zh-cmn-Hans, zh-wuu, zh-yue, zh-gan</span><br><span class="line">zh-Hans-HK、zh-Hans-MO、zh-Hans-TW、zh-Hant</span><br></pre></td></tr></table></figure><p>严格上来说，语言的标记格式为 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">language    -extlang         -script  -region    -variant -extension -privateuse</span><br><span class="line">语言文字种类 -扩展语言文字种类 -书写格式 -国家和地区 -变体     -扩展      -私有</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zh 中文，因为无法指代语言，所以废弃。但大部分服务端将此认定为 zh-Hans</span><br><span class="line">zh-Hans 汉语-简体(han 汉语, s Simplified_Chinese)</span><br><span class="line">zh-Hant 汉语-繁体(t Traditional_Chinese)</span><br></pre></td></tr></table></figure><p>实际上还有一些极为不常用的中文语种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zh-cmm</span><br></pre></td></tr></table></figure><p>还有同样不常用，而且不符合标准，但还是有用到的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zh-SG</span><br><span class="line">zh-TW</span><br><span class="line">zh-HK</span><br></pre></td></tr></table></figure><p>还有些符合标准，但并不在 Accept-Language 中受到支持的完整写法(我是不知道啥服务器认这个)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zh-cmn-Hans 国语-简体中文</span><br><span class="line">zh-cmn-Hant 国语-繁体中文</span><br><span class="line">zh-yue-Hant 粤语-繁体中文</span><br><span class="line">zh-wuu-Hans 上海话-简体中文</span><br></pre></td></tr></table></figure><p>其中 cmn 是国语，yue 是粤语，wuu 是上海话</p><h2 id="后端如何做适配"><a href="#后端如何做适配" class="headerlink" title="后端如何做适配"></a>后端如何做适配</h2><p>长远打算，最好兼容 BCP47，不过现阶段有很多历史遗留用法反而是主流</p><p>目前来说，做好这些兼容就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zh, zh-CN, zh-Hans, zh-cmn-Hans, Hans   都解析成中文</span><br></pre></td></tr></table></figure><p>不过这是一己之见，没有什么依据</p><p>短期来看，支持个 zh, zh-CN, zh-Hans 其实就够了</p><p><img src="/2020/09/id_2756259807/1.png" alt="ios语言列表"></p><h3 id="springboot"><a href="#springboot" class="headerlink" title="springboot"></a>springboot</h3><p>我们的后端使用这个，所以特意说一手</p><p>默认情况下，springboot 会将 <code>Accept-Language: zh-CN</code> 解析成 <code>Accept-Language: zh-Hans</code></p><p>匹配 message_zh_Hans.properties</p><p>若不存在，降级到 zh_CN</p><p>观测结果</p><p>简单追查，可以得出 zh-Hans 继承于 zh-CN </p><p>不过这个机制，并不是 springboot 或者 spring 的机制，是jre机制</p><p>java.util.ResourceBundle.Control#getCandidateLocales 方法的注释中，有写明对于 Chinese 的特殊处理<br>在线版本可以参考 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ResourceBundle.Control.html">https://docs.oracle.com/javase/8/docs/api/java/util/ResourceBundle.Control.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Special cases for Chinese. When an input Locale has the language &quot;zh&quot; (Chinese)</span><br><span class="line">and an empty script value, either &quot;Hans&quot; (Simplified) or &quot;Hant&quot; (Traditional)</span><br><span class="line">might be supplied, depending on the country. When the country is &quot;CN&quot; (China)</span><br><span class="line">or &quot;SG&quot; (Singapore), &quot;Hans&quot; is supplied. When the country is &quot;HK&quot; (Hong Kong</span><br><span class="line">SAR China), &quot;MO&quot; (Macau SAR China), or &quot;TW&quot; (Taiwan), &quot;Hant&quot; is supplied. </span><br><span class="line">For all other countries or when the country is empty, no script is supplied.</span><br><span class="line">For example, for Locale(&quot;zh&quot;, &quot;CN&quot;) , the candidate list will be:</span><br><span class="line">    [L(&quot;zh&quot;), S(&quot;Hans&quot;), C(&quot;CN&quot;)]</span><br><span class="line">    [L(&quot;zh&quot;), S(&quot;Hans&quot;)]</span><br><span class="line">    [L(&quot;zh&quot;), C(&quot;CN&quot;)]</span><br><span class="line">    [L(&quot;zh&quot;)]</span><br><span class="line">    Locale.ROOT</span><br><span class="line">For Locale(&quot;zh&quot;, &quot;TW&quot;), the candidate list will be:</span><br><span class="line">    [L(&quot;zh&quot;), S(&quot;Hant&quot;), C(&quot;TW&quot;)]</span><br><span class="line">    [L(&quot;zh&quot;), S(&quot;Hant&quot;)]</span><br><span class="line">    [L(&quot;zh&quot;), C(&quot;TW&quot;)]</span><br><span class="line">    [L(&quot;zh&quot;)]</span><br><span class="line">    Locale.ROOT</span><br></pre></td></tr></table></figure><h2 id="过于前沿，还没啥用的知识"><a href="#过于前沿，还没啥用的知识" class="headerlink" title="过于前沿，还没啥用的知识"></a>过于前沿，还没啥用的知识</h2><p>BCP47 在 2009年，将 zh 废弃，把 Hans, Hant 提升到了 language 层级<br>也就是说，zh-Hans 应写成 Hans</p><p>不过这个设定，没有程序认……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;网页端 i18n 必然会涉及到的 header 就是 Accept-Language&lt;/p&gt;
&lt;p&gt;相关内容可以直接参考 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-La</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>电脑上不了网的排查思路</title>
    <link href="http://www.zzmark.top/2020/07/id_1816640273/"/>
    <id>http://www.zzmark.top/2020/07/id_1816640273/</id>
    <published>2020-07-27T08:20:07.000Z</published>
    <updated>2020-07-27T08:20:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近总有连不上网瞎搞然后问我连不上网了怎么办(只说连不上，却不清楚哪里连不上，你就算说一句网页打不开了都行啊)</p><p>所以写下了这个排查思路</p><p>如果稍微懂一点命令行，知道 cmd 怎么打开怎么敲，可以直接去进阶版本，排查更快</p><h2 id="基础版"><a href="#基础版" class="headerlink" title="基础版"></a>基础版</h2><ul><li><p>是否连上了物理网络，就是网线、wifi</p><blockquote><p>这都无法保证，你是怎么舔个脸说自己网不好使的呢</p></blockquote></li><li><p>检查是否有 ip 地址</p><blockquote><p>具体方法，拿手机自行百度，操作系统不同位置不同，懒得讲</p></blockquote></li><li><p>如果是 wifi，用手机连上同一个网络试试，记得把手机流量开关给关上，不然会开着 wifi 却从流量上网，影响判断</p><blockquote><p>如果手机不能用，那么问题就在于这个网本来就不能用，自己家的话，打电话给宽带公司让他们上门修吧</p></blockquote></li><li><p>打开网页，输入 <a href="http://www.baidu.com/">www.baidu.com</a></p></li><li><p>若无法访问，输入 <a href="http://123.207.151.189/">http://123.207.151.189</a> (这是我的地址)，注意标点，只要看到 <code>404 Site 123.20xxxxxxx</code>就算成功</p><blockquote><p>如果直接访问数字地址成功，但 <a href="http://www.baidu.com/">www.baidu.com</a> 失败，可能是 dns 服务配置有误，那么重启个电脑或者等上几分钟或许自己就会好。没好的话，可能真的是配置不对；如果自己不知道什么时候配置了这东西，怀疑电脑坏了吧</p></blockquote></li><li><p>若无法访问，可能电脑出了问题，请思考是不是用了什么奇怪的软件</p></li></ul><h2 id="进阶版"><a href="#进阶版" class="headerlink" title="进阶版"></a>进阶版</h2><p>注意：该思路需要敲命令行，如果连 cmd 都不知道怎么打开，就参考上面的基础版本吧</p><p>思路如下：</p><ul><li>保证物理连接</li><li>保证有正确的 ip</li><li>电脑到网关是通的</li><li>绕过 dns 环节，可访问纯数字地址</li><li>测试 dns</li></ul><p>就这几个步骤，其中物理连接，自己看网卡状态好了</p><ul><li><p>保证有正确的 ip</p><p>cmd 输入 <code>ipconfig</code>，能看到类似于下文的内容，可能会有很多条，也可能名字和我对不上，地址和我对不上，那都不重要。</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ipconfig</span></span><br><span class="line"></span><br><span class="line">以太网适配器 以太网:</span><br><span class="line"></span><br><span class="line">  连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">  本地链接 IPv6 地址. . . . . . . . : fe80::<span class="number">48</span>c1:<span class="number">413</span>e:ee4b:<span class="number">1</span>b35%<span class="number">9</span></span><br><span class="line">  IPv4 地址 . . . . . . . . . . . . : <span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">56</span></span><br><span class="line">  子网掩码  . . . . . . . . . . . . : <span class="number">255</span>.<span class="number">255</span>.<span class="number">255</span>.<span class="number">0</span></span><br><span class="line">  默认网关. . . . . . . . . . . . . : <span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>电脑到网关是通的</p><p>上一步结果中，默认网关对应的地址，作为这步的参数</p><p>cmd 输入 <code>ping 192.168.3.1</code>，把 192.168.3.1 更换为自己的默认网关</p><p>正常结果如下：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">ping</span> <span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">1</span></span><br><span class="line"></span><br><span class="line">正在 <span class="built_in">Ping</span> <span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">1</span> 具有 <span class="number">32</span> 字节的数据:</span><br><span class="line">来自 <span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">1</span> 的回复: 字节=<span class="number">32</span> 时间&lt;<span class="number">1</span>ms TTL=<span class="number">64</span></span><br><span class="line">来自 <span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">1</span> 的回复: 字节=<span class="number">32</span> 时间=<span class="number">1</span>ms TTL=<span class="number">64</span></span><br><span class="line">来自 <span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">1</span> 的回复: 字节=<span class="number">32</span> 时间&lt;<span class="number">1</span>ms TTL=<span class="number">64</span></span><br><span class="line">来自 <span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">1</span> 的回复: 字节=<span class="number">32</span> 时间&lt;<span class="number">1</span>ms TTL=<span class="number">64</span></span><br><span class="line"></span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">1</span> 的 <span class="built_in">Ping</span> 统计信息:</span><br><span class="line">    数据包: 已发送 = <span class="number">4</span>，已接收 = <span class="number">4</span>，丢失 = <span class="number">0</span> (<span class="number">0</span>% 丢失)，</span><br><span class="line">往返行程的估计时间(以毫秒为单位):</span><br><span class="line">    最短 = <span class="number">0</span>ms，最长 = <span class="number">1</span>ms，平均 = <span class="number">0</span>ms</span><br></pre></td></tr></table></figure><p>如果长得不像(别问不像到什么程度，都是中文，一眼就能看出有问题来)，那么这一步骤失败，电脑可能出现网卡驱动问题，或者IP地址并不正确</p><p>不过这个不够准确，因为有可能路由器(网关)禁止了 ping 命令，所以无论怎样，都应当进行下一步</p></li><li><p>绕过 dns 环节，可访问纯数字地址</p><p>直接用浏览器打开 123.207.151.189，不报错就算成功</p><p>如果失败，证明网是断的。</p><p>网关能通，网却是断的，问题在上游，该找宽带报修就报修吧</p></li><li><p>测试 dns</p><p>直接访问 <a href="http://www.baidu.com,如果没通,证明/">www.baidu.com，如果没通，证明</a> dns 出了问题</p><p>可以尝试更换 dns，但别忘了测试后换回来</p><p>更换 dns 方法，自行百度</p><p>建议 223.5.5.5 阿里</p></li><li><p>dns 也没问题的情况</p><p>那么，你到底是怎么得出网不好使的呢</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近总有连不上网瞎搞然后问我连不上网了怎么办(只说连不上，却不清楚哪里连不上，你就算说一句网页打不开了都行啊)&lt;/p&gt;
&lt;p&gt;所以写下了这个排查思路&lt;/p&gt;
&lt;p&gt;如果稍微懂一点命令行，知道 cmd 怎么打开怎么敲，可以直接去进阶版本，排查更快&lt;/p&gt;
&lt;h2 id=&quot;基础</summary>
      
    
    
    
    <category term="日常" scheme="http://www.zzmark.top/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>TIME_WAIT 过高排查记录</title>
    <link href="http://www.zzmark.top/2020/07/id_708295649/"/>
    <id>http://www.zzmark.top/2020/07/id_708295649/</id>
    <published>2020-07-27T08:11:45.000Z</published>
    <updated>2020-07-27T08:11:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>线上服务器遇到了 TIME_WAIT 很高的情况，虽然服务没什么问题，机器剩余的配置很大(总计占用还不足机器的五分之一)，不过这问题很可能成为隐患，所以排查了一番，记录如下：</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol><li><p>TIME_WAIT 的来源</p><img src="/2020/07/id_708295649/1.png" class="" title="TCP三次握手、四次挥手"><p>TCP 的三次握手、四次挥手，<br>常用的三个状态是：<code>ESTABLISHED</code> 表示正在通信，<code>TIME_WAIT</code> 表示主动关闭，<code>CLOSE_WAIT</code> 表示被动关闭<br>三次握手：<br>第一次，主动端发送<code>SYN</code>给 <code>LISTEN</code> 中的被动端，自己切换至 <code>SYN-SENT</code> 状态；<br>第二次，被动端发送<code>ACK</code>确认收到信号和<code>SYN</code>；<br>第三次，主动端发送<code>ACK</code>确认收到被动端<code>SYN</code>。<br>完成上述动作后，两端进入enblished</p><p>四次挥手中，<br>第一次是主动端断开，发送<code>FIN</code>信号，切换至<code>FIN-WAIT-1</code>状态；<br>第二次是被动端收到<code>FIN</code>信号，切换至<code>CLOSE-WAIT</code>状态，然后发送<code>ACK</code>至主动端，主动端收到后切换至<code>FIN-WAIT-2</code>；<br>第三次是被动端等自己的应用断开连接时，发送<code>FIN</code>信号给主动端，被动端切换至<code>LAST-ACK</code>；<br>第四次是主动端收到被动端的<code>FIN</code>信号，然后发送<code>ACK</code>信号，切换至<code>TIME-WAIT</code>状态，等待内核回收。</p></li></ol><h2 id="百度带来的坑"><a href="#百度带来的坑" class="headerlink" title="百度带来的坑"></a>百度带来的坑</h2><p>随手搜索问题之后，无论是 baidu 还是 google，搜到的大量内容，都是叫你优化 <code>net.ipv4</code> 这种治标不治本的方法，什么加快 TIME_WAIT 回收啊，增大量级啊</p><p>但是，问题的来源并没有解决，以往的经验表明，这么调整或许能解决问题，但连接反复开闭产生的资源消耗依然很大</p><h2 id="定位-TIME-WAIT-原因"><a href="#定位-TIME-WAIT-原因" class="headerlink" title="定位 TIME_WAIT 原因"></a>定位 TIME_WAIT 原因</h2><p>根据 TCP 握手规则，谁有<code>TIME-WAIT</code>，谁就是主动端。这点可以排除用户频繁访问或错误的释放连接的可能。</p><p>意思就是说这都是服务器主动请求断开连接的，而<code>TIME-WAIT</code>状态的链接也没有回收。</p><p>服务端可能产生的请求，也就只有服务间互相调用、访问第三方 API、反向代理</p><p>其实到这里已经快要破案了，要么是程序的 bug，要么是反向代理配置带来的大量 TIME_WAIT</p><p>接下来就是具体定位，连接到底是谁产生的了。</p><h3 id="拓扑"><a href="#拓扑" class="headerlink" title="拓扑"></a>拓扑</h3><p>目前线上很精简，只有一台机器，使用 docker 作为业务容器，外侧 nginx 做入口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">              (docker)</span><br><span class="line">       |-----------------|</span><br><span class="line">nginx -&gt; traefik -&gt; api</span><br><span class="line">       |-----------------|</span><br></pre></td></tr></table></figure><p>nginx 持有 80 443 端口，traefik 通过 12500 暴露到主机，docker内的服务不对主机暴露端口</p><p>为啥这么设计？</p><p>Let’s encrypt 的证书最近因 akamai 被墙导致 OCSP 无法执行，iOS 端首次请求会等待数秒钟，这对于用户不可接受，而我们又没有购买证书或者更换国内证书的打算(子域名有点多，申请起来太累，还是 acme.sh 来得爽)(还是穷的)</p><p>然而 traefik 并不能处理 <code>OCSP stapling</code>，只好让 nginx 扛起 <code>https</code> 的大任</p><h3 id="命令排查"><a href="#命令排查" class="headerlink" title="命令排查"></a>命令排查</h3><p>(因为执行时的命令结果没有保存，所以这里只有看出情况的命令行了)</p><p>查看 TIME_WAIT 属于哪个连接</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tn|grep TIME_WAIT|awk <span class="string">&#x27;&#123;print $4&#125;&#x27;</span>|sort|uniq -c|sort -nr|head</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@m ~]# netstat -tn|grep TIME_WAIT|awk &#39;&#123;print $4&#125;&#39;|sort|uniq -c|sort -nr|head</span><br><span class="line">   2703 127.0.0.1:12500</span><br><span class="line">      2 172.17.3.142:3306</span><br></pre></td></tr></table></figure><p>可以看出，<code>127.0.0.1:12500</code> 持有 2703个 TIME_WAIT，这个端口是后端API服务的监听端口。因为 TIME_WAIT 都是主动方持有，也就是说请求是由本机的程序发往后端 API 的，也就是猜测中的第三种-反向代理的请求</p><p>不过这还没法破案，然后是分析请求来源</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ant|grep 127.0.0.1:12500</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@m ~]# netstat -antp|grep 127.0.0.1:12500</span><br><span class="line">tcp        0      0 127.0.0.1:37860         127.0.0.1:12500         TIME_WAIT  -</span><br><span class="line">tcp6       0      0 127.0.0.1:12500         127.0.0.1:37828         TIME_WAIT  -</span><br><span class="line">tcp6       0      0 127.0.0.1:12500         127.0.0.1:37748         TIME_WAIT  -</span><br><span class="line">tcp6       0      0 127.0.0.1:12500         127.0.0.1:37782         TIME_WAIT  -</span><br><span class="line">tcp6       0      0 127.0.0.1:12500         127.0.0.1:37728         TIME_WAIT  -</span><br><span class="line">tcp6       0      0 127.0.0.1:12500         127.0.0.1:37802         TIME_WAIT  -</span><br><span class="line">tcp6       0      0 127.0.0.1:12500         127.0.0.1:37864         TIME_WAIT  -</span><br><span class="line">tcp6       0      0 127.0.0.1:12500         127.0.0.1:37720         TIME_WAIT  -</span><br><span class="line">tcp6       0      0 127.0.0.1:12500         127.0.0.1:37770         TIME_WAIT  -</span><br><span class="line">tcp6       0      0 127.0.0.1:12500         127.0.0.1:37844         TIME_WAIT  -</span><br><span class="line">tcp6       0      0 127.0.0.1:12500         127.0.0.1:37810         TIME_WAIT  -</span><br><span class="line">tcp6       0      0 127.0.0.1:12500         127.0.0.1:37852         TIME_WAIT  -</span><br><span class="line">tcp6       0      0 127.0.0.1:12500         127.0.0.1:37752         TIME_WAIT  -</span><br><span class="line">tcp6       0      0 127.0.0.1:12500         127.0.0.1:37742         TIME_WAIT  -</span><br><span class="line">tcp6       0      0 127.0.0.1:12500         127.0.0.1:37870         TIME_WAIT  -</span><br><span class="line">tcp6       0      0 127.0.0.1:12500         127.0.0.1:37832         TIME_WAIT  -</span><br><span class="line">tcp6       0      0 127.0.0.1:12500         127.0.0.1:37762         TIME_WAIT  -</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>因为都在本地，这命令下去根本看不出啥来<br>如果是外来请求，或者其他 ip 的请求，那么后方的 127.0.0.1 就会显示那一方的 ip</p><p>如果运气好，能看到 127.0.0.1:12500 在后边，也就是第五个参数位置，那么可以尝试翻一翻是否有最后一个参数，若 TIME_WAIT 占比不是特别绝望，应该能看到几个。<br>而这几个很有可能就是发起者。也算是种猜测了。</p><p>到这里我也没什么排查手段了，因为请求来源是 127.0.0.1，不好确认是哪里来的请求。<br>这也就是单节点带来的痛苦……</p><p>不过按照前面的线索，nginx 的可能性很大</p><h2 id="nginx-带来的-TIME-WAIT"><a href="#nginx-带来的-TIME-WAIT" class="headerlink" title="nginx 带来的 TIME_WAIT"></a>nginx 带来的 TIME_WAIT</h2><ol><li><p>导致 nginx端出现大量TIME_WAIT的情况有两种：</p><p>keepalive_requests设置比较小，高并发下超过此值后nginx会强制关闭和客户端保持的keepalive长连接；（主动关闭连接后导致nginx出现TIME_WAIT）<br>keepalive设置的比较小（空闲数太小），导致高并发下nginx会频繁出现连接数震荡（超过该值会关闭连接），不停的关闭、开启和后端server保持的keepalive长连接；</p></li><li><p>解决方案</p><p>对于反向代理，nginx 提供了一个 upstream 的参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream http_backend &#123;</span><br><span class="line">  server 127.0.0.1:12500;</span><br><span class="line">  keepalive 50;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样便能解决问题。</p><p>下面是该参数的相关逻辑以及官方对此的说明：</p><p><a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive">http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive</a></p></li><li><p>The connections parameter sets the maximum number of idle keepalive connections to upstream servers that are preserved in the cache of each worker process. When this number is exceeded, the least recently used connections are closed.（设置每个 worker 进程保留与上游服务器的 keepalive 连接最大数量。超过此数量时，将关闭最近最少使用的连接。）</p></li><li><p>It should be particularly noted that the keepalive directive does not limit the total number of connections to upstream servers that an nginx worker process can open.（特别提醒：keepalive指令不会限制一个nginx worker到 upstream 连接的总数量）</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;线上服务器遇到了 TIME_WAIT 很高的情况，虽然服务没什么问题，机器剩余的配置很大(总计占用还不足机器的五分之一)，不过这问题很可能成为隐患，所以排查了一番，记录如下：&lt;/p&gt;
&lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="运维" scheme="http://www.zzmark.top/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="运维" scheme="http://www.zzmark.top/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="nginx" scheme="http://www.zzmark.top/tags/nginx/"/>
    
    <category term="Linux" scheme="http://www.zzmark.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>记录DHCP-clientid导致IP冲突</title>
    <link href="http://www.zzmark.top/2020/05/id_661479498/"/>
    <id>http://www.zzmark.top/2020/05/id_661479498/</id>
    <published>2020-05-06T09:43:44.000Z</published>
    <updated>2020-05-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本次问题基于 ubuntu 1804, centos用户不要对坐(号)入号(座)</p><p>最近弄了一台物理服务器，复制了几个 ubuntu 1804，但出了一个神奇问题，这几台机器无一例外，dhcp获取的都是同一个ip</p><p>百思不得其解的问题，明明 mac 地址不同，为何会出这种事情</p><p>然后开始了排查历程</p><p>先做几个备忘：</p><ul><li>ubuntu 1804，废弃了 ifupdown，改用 netplan 配置网络，学习成本不高，配置文件在 /etc/netplan/*.yaml，语法比较简单</li><li>可能用到的命令行 <ul><li>netplan ip leases <code>&lt;device&gt;</code> 查看网卡信息</li><li>netplan try 执行配置</li></ul></li></ul><p>排查过程中，做了以下尝试：</p><ul><li>尝试了重启网卡</li><li>重启网络服务</li><li>重启机器</li><li>dhclient 重新分配 ip</li></ul><p>无果</p><p>重启网卡时，还遇到了 ifdown 不存在，原来是被废弃了，用 netplan 替代</p><p>但在 netplan ip leases 中，发现了一个参数， CLIENTID，这几台虚机的id是完全一致的</p><p>我的直觉告诉我，问题就在这里</p><p>翻到了靠谱的 <a href="https://tools.ietf.org/html/rfc4361">RFC-4361 Node-specific Client Identifiers for Dynamic Host Configuration Protocol Version Four (DHCPv4)</a> 规范</p><p>知其所以然，还是不知道咋解决……</p><p>netplan 提供了这个参数 <a href="http://manpages.ubuntu.com/manpages/cosmic/man5/netplan.5.html">dhcp-identifier</a></p><p>提供了可以用 mac 当作 dhcp clientid 的配置，尝试一番，可行</p><p>剩下的基础知识，有空再补充</p><hr><p>2020-05-18 更新</p><p>dhcp clientid 的默认值会根据 machine id 变更，克隆出的几台机器完全一致，所以这里才是真正的祸根</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 machine-id</span></span><br><span class="line">cat /etc/machine-id</span><br></pre></td></tr></table></figure><p>可以使用 dbus-uuidgen 来重新生成一个 machine-id</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -f /etc/machine-id</span><br><span class="line">sudo dbus-uuidgen --ensure=/etc/machine-id</span><br></pre></td></tr></table></figure><p><a href="https://unix.stackexchange.com/questions/402999/is-it-ok-to-change-etc-machine-id">https://unix.stackexchange.com/questions/402999/is-it-ok-to-change-etc-machine-id</a></p><p>然后重新使用 netplan apply 获取ip，收工。</p><p>然后，写了个一次性脚本来做这个工作。方式多的很，自行研究了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本次问题基于 ubuntu 1804, centos用户不要对坐(号)入号(座)&lt;/p&gt;
&lt;p&gt;最近弄了一台物理服务器，复制了几个 ubuntu 1804，但出了一个神奇问题，这几台机器无一例外，dhcp获取的都是同一个ip&lt;/p&gt;
&lt;p&gt;百思不得其解的问题，明明 mac </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>端口连通性测试</title>
    <link href="http://www.zzmark.top/2020/04/port-connectivity/"/>
    <id>http://www.zzmark.top/2020/04/port-connectivity/</id>
    <published>2020-04-02T12:57:20.000Z</published>
    <updated>2020-04-02T12:57:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>此文送给刚开始折腾服务器的小伙伴</p><p>有时候，端口无法访问，可能出现的问题很多。</p><p>排查要按照章法来，这是我自己总结的流程，不是太完全但大概够用，有些环境没有那么多环节，自行过滤。</p><ul><li>检测端口监听</li><li>保证端口在最近的点(localhost)可用</li><li>检查防火墙、SELinux</li><li>检查安全组（云服务器）</li><li>检查服务端交换机转发、出入规则（一般人用不到）</li><li>检测本地段是否禁止出流量（受限制的网络环境）</li><li>检查一下自己脑子是不是坏了</li></ul><p>如果某一行你完全不懂又在这说我讲得太难，那直接选择最后一行，考虑考虑是否需要退出这个行业。</p><h2 id="检测端口监听"><a href="#检测端口监听" class="headerlink" title="检测端口监听"></a>检测端口监听</h2><p>首先要保证端口开启，最简单的方法就是使用 netstat, ss 这两个工具。ss 限于 linux，参数用法自行查找<br>根据系统不同，命令参数和用法都有不同，这里列举几个常用的命令供大家复制。</p><p>windows:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">直接打印出所有端口情况，-o 打印出使用端口的 PID。如何使用 PID 自行百度</span><br><span class="line">netstat -ano</span><br><span class="line"></span><br><span class="line">指定查 8080 端口情况</span><br><span class="line">netstat -ano | findstr 8080</span><br><span class="line"></span><br><span class="line">查询所有 TCP&#x2F;UDP 端口情况</span><br><span class="line">netstat -ano -p tcp&#x2F;udp</span><br></pre></td></tr></table></figure><p>Linux:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">直接打印出所有端口情况，-p 打印出使用端口的 PID</span><br><span class="line">netstat -anp</span><br><span class="line"></span><br><span class="line">指定查 8080 端口情况</span><br><span class="line">netstat -anp | grep 8080</span><br><span class="line"></span><br><span class="line">仅查看 tcp 端口监听情况(注意是监听)，udp 把 t 换成 u</span><br><span class="line">netstat -nltp</span><br></pre></td></tr></table></figure><p>使用该工具可以查看到端口状态，其中，LocalAddress 列可以看到监听是在哪一个网段</p><p>这时候关注的端口如果是 LISTEN 状态，并且监听的网段是自己需要的网段，就没有问题(不懂的话去查查 ipv4 如何划分网段的，以及子网掩码怎么用)</p><p>tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      851/sshd</p><p>一般人会见到的情况有两种(如果你用docker或者其他容器技术，另讲)，拿 sshd 为例，0.0.0.0:22 或者 127.0.0.1:22，前者任何网卡都通，后者只能在回环地址上用(也就是本机)</p><h2 id="如何测试端口是否可达"><a href="#如何测试端口是否可达" class="headerlink" title="如何测试端口是否可达"></a>如何测试端口是否可达</h2><p>确保端口监听后，就要在不同的点测试端口是否可用。若不可用，先检查端口是否可达，再检查端口业务是否正常</p><p>如果端口在最远端不可达，就先去最近端检查可用性，确保端口和业务是真的可用。</p><p>tcp端口可达很容易测，只需要使用这个十分常用的工具 telnet 即可，这个工具目前不是系统自带，需要安装一下，具体过程自行查询</p><p>telnet 基于 socket(写IO的人都知道)，典型的应用是可以检测 ssh 端口和 http 端口是否可用，这对于排查防火墙、安全组等问题很有用处。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet [ip] [port]</span><br></pre></td></tr></table></figure><p>但是 udp 端口很难检测，telnet 可以做 tcp 握手，但是 udp 无法实现。</p><p>实际上也有一个工具，虽然不是做这个功能的，但是可以实现排查 udp 端口是否可达，这个工具就是 nc(ncat)</p><p>不过这个排查思路不同于 tcp，只能检测端口是否可达，无法检测业务是否正常</p><p>nc 是个网络工具，可以绑定某个端口用来接收，另一端同样用 nc 发包，这工具可以检测某个 udp 端口被防火墙丢弃或者被中间路由封锁。</p><p>如下命令可构成一个 udp 发送通道</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">服务端：</span><br><span class="line">nc -u -l -p 4000</span><br><span class="line"></span><br><span class="line">客户端</span><br><span class="line">nc -u 10.0.0.2 4000</span><br></pre></td></tr></table></figure><p>比如 4000/udp 是 QQ 需要的端口，检测网络环境是否封禁 4000/udp 就可以在服务器上开监听端，自己电脑使用客户端</p><p>这个工具也可以检测 tcp 连通性，把 -u 去掉即可</p><h2 id="剩下的排查思路"><a href="#剩下的排查思路" class="headerlink" title="剩下的排查思路"></a>剩下的排查思路</h2><p>这篇文章就是个入门教程，工具用什么都好，关键是思路。</p><p>网不通先要考虑机器是否可达，可达的情况下就要一步步排查中间环节是否连通</p><p>至于业务怎么检测可用，那应该问端口业务</p><h2 id="不好归类的东西"><a href="#不好归类的东西" class="headerlink" title="不好归类的东西"></a>不好归类的东西</h2><p>有一些可能用到的其他工具，怎么用自行搜索吧</p><p>抓包工具：</p><ul><li>tcpdump<br>tcpdump -nl -A port 1883</li></ul><p>常用的网络检测工具：</p><ul><li>mtr<br>等同于同时使用 ping, tracert, nslookup</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;此文送给刚开始折腾服务器的小伙伴&lt;/p&gt;
&lt;p&gt;有时候，端口无法访问，可能出现的问题很多。&lt;/p&gt;
&lt;p&gt;排查要按照章法来，这是我自己总结的流程，不是太完全但大概够用，有些环境没有那么多环节，自行过滤。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;检测端口监听&lt;/li&gt;
&lt;li&gt;保证端口在最</summary>
      
    
    
    
    <category term="环境" scheme="http://www.zzmark.top/categories/%E7%8E%AF%E5%A2%83/"/>
    
    
    <category term="运维" scheme="http://www.zzmark.top/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>用 wifi 模块配合继电器远程开机</title>
    <link href="http://www.zzmark.top/2020/04/remote-relay/"/>
    <id>http://www.zzmark.top/2020/04/remote-relay/</id>
    <published>2020-04-02T12:45:20.000Z</published>
    <updated>2020-04-02T12:45:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>为了给主板做远程开关机，搞了这么一个玩具</p><p>实际上想要实现该目的，有以下几个方案</p><ul><li><strong>Wake On Lan(WOL)</strong> 技术成本最低，但技嘉的主板想打开这个需要关闭快速启动以及一大堆的东西，很反感。</li><li>论实施成本，找个远程控制的智能插座，配合主板的掉电处理，也能实现目的，只不过自己用电脑想开机，也得通过这个，体验很差</li></ul><p>最近比较闲，买了几个 wifi 模块，配了个继电器，搞起了这么个玩具</p><p>先声明，我不是专业玩单片机、嵌入式、物联网设备的，下文可能有许多不专业的地方，虚心请教，望好心人指出。</p><h2 id="物料清单"><a href="#物料清单" class="headerlink" title="物料清单"></a>物料清单</h2><ul><li>esp-01s(esp8266)，淘宝10块包邮</li><li>esp-01s 继电器模块，淘宝10块包邮</li><li>ttl 刷机工具，淘宝5块包邮</li></ul><p>图中是esp-01s 继电器模块，不要在意那两个裸漏的线</p><img src="/2020/04/remote-relay/1-1.jpg" class="" title="1-1"><h2 id="玩法"><a href="#玩法" class="headerlink" title="玩法"></a>玩法</h2><p>esp8266 这个模块，十分的便宜，脚位齐全、搭配 ch340 串口芯片的开发板也只不过14块包邮，简化引脚的 esp-01s 更是 8 块都不到</p><p>80/160Mhz主频，80k ram，1Mbyte 或 4Mbyte rom，乐鑫官方甚至提供了 FreeRTOS 操作系统固件，虽然我不会用</p><p>生态十分齐全，当作玩具来玩的话，有 c、python(<a href="http://docs.micropython.org/en/latest/esp8266/quickref.html">MicroPython</a>)、javaScript(<a href="https://www.espruino.com/EspruinoESP8266">Espruino</a>)、Lua(<a href="https://nodemcu.readthedocs.io/en/master/">NodeMCU</a>) 语言可选，资料很全</p><p>远程控制方案，我选择了mqtt下发消息，模块改写引脚电平，触发继电器</p><p>就这么点功能，用什么语言写也就十几行的样子，不过最后我选择了 Espruino，随便写了一下，算是实现了功能</p><p>选用一些实时操作系统，比如 FreeRTOS、RIOT，都要用 linux 系统，交叉编译之类的，手上的 linux 都是服务器版，这点需求懒得折腾</p><h2 id="零碎的点"><a href="#零碎的点" class="headerlink" title="零碎的点"></a>零碎的点</h2><ul><li><p>esp8266 均采用 3.3v 供电，刷写固件时官方要求电流为200ma，一般的 ttl 模块供电都足够，不过我用了辣鸡的 usb2.0 hub，供电不足，刷写成功但过不了开机的 checksum，刷了几次，概率性失效，最终换到了主机上的usb孔，解决问题</p></li><li><p>连接wifi，最简单的方法就是直接输入 SSID 和 password，但是 SSID 如果涉及非 ASCII 内容，需要按UTF-8输入，否则连不上。</p></li><li><p>wifi 天线增益很小(esp-01s是印刷天线，估计是2db的)，太远了 mqtt 就会各种断线，虽然 mqtt 会重连</p></li><li><p>esp8266 的 ttl 启动时会有启动 log，可以看到一些硬件相关的初始化信息，但波特率在 74880，直接用 115200 会表现为一堆乱码<br>启动成功后，官方固件可以使用 AT 命令测试一下是否可用，发送 AT 应该会返回 <code>OK</code>，查看当前固件信息的命令为 <code>AT+GMR</code></p></li><li><p>ESP-01s 的 GPIO2 是绑定了指示灯的，也就是改动 GPIO2 引脚</p></li><li><p>如果用 C 语言，是支持 OTA 的，其他几个语言的环境似乎没有这个功能，Espruino 的代码是通过 ttl 写入的，类似于浏览器，并不需要烧录即可变更代码，并且提供了 ttl 封装重定向的相关内容。</p></li><li><p>Espruino，执行代码很像终端(实际上就是个终端)，IDE 的原理是把代码执行一遍，执行过后需要自己写保存动作，否则重启就会重新初始化。不过 wifi 相关的信息，是写在硬件中的，调用 save(); 之后就不会丢失。</p><p>所以代码可以遵循一个模板</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E.on(<span class="string">&#x27;init&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  init();</span><br><span class="line">&#125;);</span><br><span class="line">save();</span><br></pre></td></tr></table></figure></li><li><p>Espruino 的 telnet，如果使用 XShell，有时候就会出现类似下图的 EOF 异常，这个可能是 telnet 实现不完全或者客户端混入了奇怪的字符，输入前先按一下 Ctrl + C，就没事了<br>不过使用 windows 自带的 telnet，会有回显，很是别扭，或许可以用命令关掉回显。</p></li></ul><h2 id="过程和成果"><a href="#过程和成果" class="headerlink" title="过程和成果"></a>过程和成果</h2><p>起初购买继电器和模块时，贪便宜翻车了。</p><p>淘宝上能找到的版本有两种，v1.0，v4.0，两者引脚定义应该是一致的，最开始买到了 v1.0，但这个版本默认给 GPIO0 下拉，通电进入下载模式，测试 GPIO0 插槽到 GND 有1.24v 电压，认定翻车了。</p><p>IO接线什么的，随便搜一下就有，如下图</p><img src="/2020/04/remote-relay/1-2.jpg" class="" title="1-2"><p>最终成品大概是这样，ttl 供电测试，不要在意</p><img src="/2020/04/remote-relay/1-3.jpg" class="" title="1-3"><hr><p>软件部分，选用 mqtt 下发命令，触发代码更改引脚状态。</p><p>ESP-01s 的引脚很少，GPIO0, GPIO2, RX, TX，淘宝的模块都是 GPIO0 触发</p><p>所以，整个的折腾流程就是这样：</p><ul><li>ttl 刷写 Espruino 固件</li><li>搭建 mqtt 服务端，我选用了 EMQX，十分专一的 mqtt 服务器，曾经在线上用过的技术，比较熟悉</li><li>引入 tinyMQTT 代码库，编写业务代码</li><li>GPIO0 和 GPIO2 同步操作，这样可以通过板子上的灯观察结果</li><li>装板，测试继电器通断</li></ul><p>先来个 Hello world</p><img src="/2020/04/remote-relay/1-4.jpg" class="" title="1-4"><p>然后写入代码，存进去。</p><p>最终运行状态</p><img src="/2020/04/remote-relay/1-6.jpg" class="" title="1-6"><img src="/2020/04/remote-relay/1-5.jpg" class="" title="1-5"><h2 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h2><p>因为模块的因素，通电时会有一次的继电器闭合，所以给电就会触发一次，目前还不晓得怎么处理</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;为了给主板做远程开关机，搞了这么一个玩具&lt;/p&gt;
&lt;p&gt;实际上想要实现该目的，有以下几个方案&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Wake On Lan(WOL)&lt;/strong&gt; 技术成本最低，但技嘉的主板想打开这个需要关闭快速启动以及一大堆的东西，很反感。&lt;/li</summary>
      
    
    
    
    <category term="Iot" scheme="http://www.zzmark.top/categories/Iot/"/>
    
    
    <category term="Iot" scheme="http://www.zzmark.top/tags/Iot/"/>
    
  </entry>
  
  <entry>
    <title>前端项目迁移至 nuxt.js</title>
    <link href="http://www.zzmark.top/2020/02/id_3995044274/"/>
    <id>http://www.zzmark.top/2020/02/id_3995044274/</id>
    <published>2020-02-22T13:29:29.000Z</published>
    <updated>2020-02-22T13:29:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章书写于 2019-09-06，改造是8月中旬，使用的 nuxt.js 版本为 2.8.1，后升级到2.9.0，文中可能包含两个版本的内容，区别不是太大，关于版本差距详见<a href="https://github.com/nuxt/nuxt.js/releases">nuxt/nuxt.js</a></p><p>目前项有 SEO 的需求，而前端是纯正的 SPA 应用，国内的搜索引擎目前对这些东西都没有办法，所以考虑启用 SSR 服务端渲染方案</p><p>官方提供了三种可行方案</p><ul><li><a href="https://ssr.vuejs.org/">vue-server-renderer 服务端方案</a></li><li><a href="https://github.com/chrisvfritz/prerender-spa-plugin">prerender-spa-plugin webpack预渲染插件</a></li><li><a href="https://nuxtjs.org/">nuxt.js</a></li></ul><p>如果页面较少并且固定，那还是推荐使用预渲染方案，不过我们有详情页面需要渲染，所以这个方案无法实现，而 vue-server-renderer 因为要搭建太多内容，我们追求快速落地，所以该方案 pass。</p><p>我们最终选用了 nuxt.js，本文记录整个迁移过程和遇到的坑</p><h2 id="intro"><a href="#intro" class="headerlink" title="intro"></a>intro</h2><p>目前项目结构为</p><ul><li>webpack, typescript, sass</li><li>vue, vuex, vue-router</li><li>element-ui</li><li>axios</li><li>baidu-map</li></ul><p>没有 jquery，手脚架为 vue-cli3 的官方手脚架(用 vue-cli-service 启动的)。</p><p>项目中大部分数据都放进了 vuex，包括登录，vuex 的数据自动保存到 localStorage 中</p><p>注意，本文的大部分说法，都是基于 typeScript，有些说法可能在 js 环境不适用，请自行测试</p><p>还要说一句，typeScript 搞这东西，真不太好用</p><h2 id="nuxt-js"><a href="#nuxt-js" class="headerlink" title="nuxt.js"></a>nuxt.js</h2><p>看官网吧</p><p>加一些我自己的补充</p><p>nuxt 的工作模式，按照我自己的话来说就是混合渲染，只有页面在首次加载时会触发服务端渲染，前端的交互操作依然遵照 SPA 的方式。</p><p>这个逻辑必须要理解，不然会遇到各种数据不加载、undefined、页面多次渲染等等一系列问题。</p><p>对新手说的话，就是浏览器刷新、地址栏敲回车。</p><p>然后，nuxt 的 asyncData 和 fetch 两部分，可能在服务端执行可能在客户端执行，但一定只执行一次，所以 asyncData 和 fetch 必须要设计成服务端和客户端都可以执行的结构。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>nuxt.js 的生命周期<br><img src="https://zh.nuxtjs.org/nuxt-schema.png" alt="img"></p><p>vue.js 的生命周期<br><img src="https://vuejs.org/images/lifecycle.png" alt="img"></p><p>其中，nuxt.js 的 Render 部分，后续会接上 vue.js 的生命周期，包含 beforeCreate 和 created，而浏览器端也会再执行 beforeCreate 和 created 两个钩子，这是服务端渲染的性质。</p><h2 id="框架搭建"><a href="#框架搭建" class="headerlink" title="框架搭建"></a>框架搭建</h2><p>不建议自行添加依赖，最好是直接官方手脚架生成，然后将现有项目迁移上去</p><p>原有项目的目录结构如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">├─public</span><br><span class="line">├─scripts</span><br><span class="line">├─src</span><br><span class="line">│  ├─api</span><br><span class="line">│  ├─assets</span><br><span class="line">│  │  ├─font</span><br><span class="line">│  │  ├─images</span><br><span class="line">│  │  └─scss</span><br><span class="line">│  ├─components</span><br><span class="line">│  ├─config</span><br><span class="line">│  ├─router</span><br><span class="line">│  ├─store</span><br><span class="line">│  │  └─module</span><br><span class="line">│  ├─types</span><br><span class="line">│  │  ├─components</span><br><span class="line">│  │  └─views</span><br><span class="line">│  ├─utils</span><br><span class="line">│  ├─views</span><br><span class="line">│  │  └─index</span><br><span class="line">│  ├─App.vue</span><br><span class="line">│  └─main.ts</span><br><span class="line">├─tslint.json</span><br><span class="line">├─tsconfig.json</span><br><span class="line">├─vue.config.js</span><br><span class="line">├─package.json</span><br></pre></td></tr></table></figure><p>因为 nuxt.js 的目录结构有规范，可以用来实现很多功能，所以基本上遵照了目录结构<br>新的目录结构为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">├─.nuxt</span><br><span class="line">├─server</span><br><span class="line">│  ├─middleware</span><br><span class="line">|  └─index.js</span><br><span class="line">├─src</span><br><span class="line">│  ├─api</span><br><span class="line">│  ├─assets</span><br><span class="line">│  │  ├─font</span><br><span class="line">│  │  ├─images</span><br><span class="line">│  │  └─scss</span><br><span class="line">│  ├─components</span><br><span class="line">│  ├─config</span><br><span class="line">│  ├─layouts</span><br><span class="line">│  ├─middleware</span><br><span class="line">│  ├─pages</span><br><span class="line">│  │  ├─index</span><br><span class="line">│  │  └─index.vue</span><br><span class="line">│  ├─plugins</span><br><span class="line">│  ├─static</span><br><span class="line">│  ├─store</span><br><span class="line">│  ├─types</span><br><span class="line">│  │  ├─components</span><br><span class="line">│  │  │  └─userCenter</span><br><span class="line">│  │  └─views</span><br><span class="line">│  └─utils</span><br><span class="line">├─tslint.json</span><br><span class="line">├─tsconfig.json</span><br><span class="line">├─vue.config.js</span><br><span class="line">├─package.json</span><br><span class="line">├─nuxt.config.js</span><br></pre></td></tr></table></figure><p>这样调整尽量符合原有结构，为了这个目录结构还需要配置几个属性</p><p>nuxt.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">&#x27;universal&#x27;</span>,</span><br><span class="line">  srcDir: <span class="string">&#x27;src&#x27;</span>, <span class="comment">// 将源码路径指向 src，默认同 rootDir 为项目根目录</span></span><br><span class="line">  <span class="comment">// other...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nuxt.js 是自动生成路由的，所以取消了 router 目录，如果要干预可以在 nuxt.config.js 手动注入额外部分，但自动部分还是会工作；<br>如果要对路由进行影响可以增加 middleware，在路由响应时改变上下文或者改变路由目的地；<br>对于动态菜单这种需求，那种后管平台没有 SSR 的必要，建议放弃</p><p>原有项目的 views 更名为 page，因为自动生成路由，所以目录结构要按照 nuxt.js 的规则来，详见 <a href="#pages">迁移指南-pages</a></p><p>assert 和 static 都是放置静态资源的地方，区别在于 assert 通过 loader 加载，可以解析 sass 等格式，而 static 为纯静态资源</p><p>components 为组件，这部分不会受到 nuxt.js 加强，也就是没有 nuxt.js 的生命周期钩子。注意该部分打包时会全部封进 app.js，如果组件是某个页面专用，就请移动到 pages 中，不要放在这里</p><p>layouts 作为布局，所有渲染的页面都要有一个对应布局，默认的布局名称为 default.vue，就是渲染模板，这里可以一定程度代替 App.vue 和 main.ts</p><p>middleware 放置路由中间件，中间的 js 文件会自动以文件名为 name 注册进 nuxt.js，在 nuxt.config.js、layouts、pages 中可以使用中间件。<br>layouts、pages 中，使用属性 <code>middleware: &#123;&#123;name&#125;&#125;</code> 即可；<br>nuxt.config.js 中按照这个格式注入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  router: &#123;</span><br><span class="line">    middleware: <span class="string">&#x27;stats&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>plugins 文件夹内的文件会做为定制原型链的插件。因为渲染机制问题，Vue 的实例初始化没有暴露出来，nuxt 提供的方案是使用 plugins。<br>但是有很多插件注入后会出现问题影响 nuxt 正常工作，谨慎使用</p><p>store 为 vuex 的目录，nuxt 会自动生成 vuex 树，只要将 store 文件直接放入 store 目录就行，nuxt 会根据文件名生成 modules</p><h2 id="迁移指南"><a href="#迁移指南" class="headerlink" title="迁移指南"></a>迁移指南</h2><p>迁移方案选择新搭建框架，再将业务代码迁移上去。</p><p>第一步迁移的是基础工具和接口代码。</p><p>然后迁入基础结构，首先处理 App.vue 和 main.ts</p><p>App.vue 对应到 layouts/default.vue 中，根据 nuxt.js 的结构做一些替换。概念不同，但结果一致。<br>日后还是更建议将 header、footer 分发到 layouts 中，可以更好的规划布局和统一布局</p><p>整体的代码执行顺序如下，自行对照到生命周期中：</p><p>nuxt.js =&gt; plugins =&gt; router =&gt; router-middleware =&gt; layout =&gt; asyncData/fetch =&gt; create</p><h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><p>store 会自动按照名字分 modules，所以要确保 store 文件的命名和以前引用的模块名一致，不然就要大片的改动代码</p><p>服务端渲染需要 state部分返回一个无参方法，这里用的 ES6 语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">  recentContactList: [],</span><br><span class="line">  chatRecordList: []</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>根据服务端渲染的逻辑，每次服务端渲染，vuex 都会重新初始化，vuex 的初始化在服务端，时机很早(应该是nuxtServletInit就有)，也就是说没有以前的数据。针对这一点有一些解决方案，但强烈不推荐将用户端的 vuex 同步到服务端这一做法，看似很美好但同步方面坑相当多。</p><p>对于服务端没有 vuex 数据的问题，我建议针对性的处理，如用户 token、用户关键信息 可存放到 cookie 中，一些整个项目随处都要用的数据也可以存放到 cookie 中。但注意容量，cookie 的空间很宝贵</p><p>对于 vuex 的一些初始化动作，举个例子，用户信息存放在 vuex 中，业务方都是在 vuex 中获取，我们可以在 middleware 中将用户信息从 cookie 中读出，存放到 vuex 中。</p><p>目前的前端有 localStorage 来保存 vuex 数据，但是要考虑数据合并造成的冲突，因为服务端渲染会将 服务端vuex 中的数据带到客户端，客户端会使用这些数据做初始化，确切的说是 初始化 =&gt; 合并服务端vuex，如果客户端从 localStorage 做了本地化，切记在合并数据时注意不要将服务端某些关键数据覆盖掉。</p><p>对于那些过度依赖 vuex 的功能，比如列表翻页的页码存放到 vuex，我建议着手拆除这类业务对 vuex 的依赖，vuex 不是这样的工具</p><h3 id="pages"><a href="#pages" class="headerlink" title="pages"></a>pages</h3><p>pages 为页面入口文件夹</p><p>服务端渲染的改造基本都在这里</p><p>根据路由生成规则，pages/index.vue 是首页入口</p><p>layouts 中的文件代替了 App.vue。</p><p>其中 layouts/error.vue 文件比较特别，这个是错误页面，后端渲染错误、后端路由错误，都会跳转至此。</p><h4 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h4><p>nuxt 会根据放入 pages 中的 文件夹/文件 来生成路由Router</p><p>规则为：</p>//<p>若 vue 文件为 index.vue，则不会生成文件名层级</p><p>在 Nuxt.js 里面定义带参数的动态路由，需要创建对应的以下划线作为前缀的 Vue 文件 或 目录。</p><p>以下<a href="https://zh.nuxtjs.org/guide/routing">官网样例</a>：</p><p>e.g.</p><p>假设目录结构为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pages&#x2F;</span><br><span class="line">--| about&#x2F;</span><br><span class="line">-----| index.vue</span><br><span class="line">-----| one.vue</span><br><span class="line">--| users</span><br><span class="line">-----| _id.vue</span><br><span class="line">--| _slug</span><br><span class="line">-----| comments.vue</span><br><span class="line">-----| index.vue</span><br><span class="line">--| index.vue</span><br></pre></td></tr></table></figure><p>生成的路由为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">routes: [</span><br><span class="line">  &#123;</span><br><span class="line">    name: &#39;index&#39;,</span><br><span class="line">    path: &#39;&#x2F;&#39;,</span><br><span class="line">    component: &#39;pages&#x2F;index.vue&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: &#39;about&#39;,</span><br><span class="line">    path: &#39;&#x2F;about&#39;,</span><br><span class="line">    component: &#39;pages&#x2F;about&#x2F;index.vue&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: &#39;about-one&#39;,</span><br><span class="line">    path: &#39;&#x2F;about&#x2F;one&#39;,</span><br><span class="line">    component: &#39;pages&#x2F;about&#x2F;one.vue&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">      name: &#39;users-id&#39;,</span><br><span class="line">      path: &#39;&#x2F;users&#x2F;:id?&#39;,</span><br><span class="line">      component: &#39;pages&#x2F;users&#x2F;_id.vue&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">      name: &#39;slug&#39;,</span><br><span class="line">      path: &#39;&#x2F;:slug&#39;,</span><br><span class="line">      component: &#39;pages&#x2F;_slug&#x2F;index.vue&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">      name: &#39;slug-comments&#39;,</span><br><span class="line">      path: &#39;&#x2F;:slug&#x2F;comments&#39;,</span><br><span class="line">      component: &#39;pages&#x2F;_slug&#x2F;comments.vue&#39;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h4><p>nuxt 的 SSR 可以说成是混合渲染，首次加载时由服务端渲染，其余的时间点都和 SPA 一致。</p><p>为了让服务端渲染时能将数据渲染到 html 中，就需要在 render 前将数据填充到应该放置的地方(data 或者 vuex)</p><p>再强调一次，vuex 在初始化时，是空的。</p><p>整体的流程可以参照生命周期的图</p><p>asyncData 和 fetch 两个步骤可以对数据进行影响，fetch 设计的功能就是填充 vuex。<br>asyncData 还额外的有一个特点，就是该步骤的返回值会合并到该页面的 data 属性中(ts语法可能不太明显，js 语法的 data 就比较容易理解了)。</p><p>这样就可以通过 asyncData 和 fetch 控制服务端渲染时，数据的范围</p><p>注意，asyncData 早于 render，所以这时还没有 this 使用，也就是和 vue 实例挂钩的内容都用不了。虽然 context 中提供了一个叫 app 的实例，但那个是 nuxt 的实例，不是当前页面的</p><p>还要注意，asyncData 和 fetch 都有可能在客户端执行，两者在整个流程中都只会执行一次。但是 create 生命周期在两端各会执行一次，如果可能的话，可以将 created 中的代码移植到 mounted 中。若还是需要使用 created(毕竟mounted慢一步)，可以选择使用以下代码做判断</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.client) &#123;</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ts 的写法与 js 不同，ts 中，asyncData 和 fetch 需要写在 @Components 中，如下所示，其中 asyncData 和 fetch 的入参 context 中包含的内容参见 <a href="https://zh.nuxtjs.org/api/context">Context</a></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  components: &#123; Footer, QuickBar, NoData &#125;,</span><br><span class="line">  <span class="keyword">async</span> asyncData (&#123; params, store, error &#125;) &#123;</span><br><span class="line">    <span class="keyword">if</span>(params.id) &#123;</span><br><span class="line">      <span class="keyword">let</span> a = <span class="keyword">await</span> store.dispatch(<span class="string">&#x27;AModules/ACTION_A&#x27;</span>, &#123;</span><br><span class="line">        id: params.id,</span><br><span class="line">      &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        error(&#123; <span class="attr">statusCode</span>: <span class="number">500</span>, <span class="attr">message</span>: <span class="string">&#x27;数据异常&#x27;</span> &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">fetch</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondDetails</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  <span class="comment">// other</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="meta-标签"><a href="#meta-标签" class="headerlink" title="meta 标签"></a>meta 标签</h4><p>nuxt 内部引入了 vue-meta 插件来做 meta，除了默认的命名外，使用方法完全相同，和 vuex 一样需要返回的是一个方法。具体参见 (Vue Meta)[<a href="https://vue-meta.nuxtjs.org/guide/metainfo.html]">https://vue-meta.nuxtjs.org/guide/metainfo.html]</a><br>以下官网样例: </p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123; </span><br><span class="line">  head () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      title: <span class="string">`Page 1 (<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>-side)`</span>,</span><br><span class="line">      meta: [</span><br><span class="line">        &#123; <span class="attr">hid</span>: <span class="string">&#x27;description&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;description&#x27;</span>, <span class="attr">content</span>: <span class="string">&quot;Page 1 description&quot;</span> &#125;</span><br><span class="line">      ],</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>head 的执行时机为 render，这时是可以使用 this 的</p><h4 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h4><p>先说一下，nuxt 是有 keep-alive 的，layout.vue 的 template 部分如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;Login v-show&#x3D;&quot;isLoginShow&quot; @close&#x3D;&quot;onLogin(false)&quot;&gt;&lt;&#x2F;Login&gt;</span><br><span class="line">    &lt;nuxt keep-alive&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><p>这一点不得不埋怨一下官方手册，好多东西真的是找不到，还是翻阅 changelog 和 issue 才得到的解决方案</p><h3 id="调试服务端"><a href="#调试服务端" class="headerlink" title="调试服务端"></a>调试服务端</h3><p>调试分为两部分，log 和 debug</p><p>log 可以直接在控制台看到。nuxt 2.9.0 以后新增了 ssrLog 功能，可以将服务端的 log 打印到浏览器的 console 中</p><p>debug 部分，这部分有点玄学，因为有时候代码 debugger 抓不住，我也说不太清楚</p><p>方案为，借助 node 的参数 <code>--inspect</code> 将实例的 debug 功能打开，然后使用 chrome 浏览器进行调试，本机环境只要点击 F12 就能在 Elements 选项卡左边看到 node 的图标</p><p>成功的话，在启动时就可以看到日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Debugger listening on ws:&#x2F;&#x2F;127.0.0.1:9229&#x2F;61388480-18e2-4f4d-8373-f7b9909d8011</span><br><span class="line">For help, see: https:&#x2F;&#x2F;nodejs.org&#x2F;en&#x2F;docs&#x2F;inspector</span><br></pre></td></tr></table></figure><h2 id="一些使用技巧"><a href="#一些使用技巧" class="headerlink" title="一些使用技巧"></a>一些使用技巧</h2><p><strong>js-cookie</strong></p><p>提供一个修改过的 js-cookie，可以在服务端渲染时提供相同的 api，cookie 为空时会默认读取 document</p><p><a href="https://gist.github.com/ZzMark/d93bbcbbf3b6e763062c977c269edcbf">https://gist.github.com/ZzMark/d93bbcbbf3b6e763062c977c269edcbf</a></p><p>在 asyncData 中的用法样例如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">asyncData</span>(<span class="params">&#123;req&#125;</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> cookie</span><br><span class="line">  <span class="keyword">if</span>(process.server) &#123;</span><br><span class="line">    cookie = req.headers.cookie</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> userInfo = Cookies.getJSON(<span class="string">&#x27;userInfo&#x27;</span>, cookie) || &#123;&#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>按需渲染</strong></p><p>有的地方没有必要让服务端渲染，SSR 针对性的将有必要的东西放到服务端即可。不过话是这么说，实际上反而是将不必要的去掉</p><p>不需要服务端渲染的地方，用 <no-ssr></no-ssr> 嵌套起来。</p><p>但要注意，如果不想让某个组件加载，需要在引用组件的地方用 no-ssr，不能在组件上。</p><p>典型的场景是，某个组件需要数据，没有数据导致了服务端渲染时出现了 undefined，直接用 no-ssr 将那一块套起来是没有用的</p><p>对了，no-ssr 在 nuxt3 就会被移除，尽快迁移到 <client-only></client-only> 吧</p><p><strong>全局加载scss</strong></p><p>SPA 场景下，直接 import 即可，但这里不行</p><p>可以使用 module: @nuxtjs/style-resources</p><p>在 nuxt.config.js 中配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  modules: [</span><br><span class="line">    <span class="string">&#x27;@nuxtjs/style-resources&#x27;</span>,</span><br><span class="line">  ],</span><br><span class="line">  styleResources: &#123;</span><br><span class="line">    scss: [<span class="string">&#x27;./src/assets/scss/common.scss&#x27;</span>, <span class="string">&#x27;./src/assets/scss/font.scss&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打包、优化"><a href="#打包、优化" class="headerlink" title="打包、优化"></a>打包、优化</h2><p>开发环境，建议使用 nuxt 来启动，生产环境更换为 express，方便在 express 中增加一些定制信息（我们在 express 中做了压缩相关的内容，这个下面会讲）。</p><p>附上我的启动指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;cross-env NODE_ENV&#x3D;development DEBUG&#x3D;nuxt:* node node_modules&#x2F;nuxt&#x2F;bin&#x2F;nuxt&quot;,</span><br><span class="line">&quot;debug&quot;: &quot;cross-env NODE_ENV&#x3D;development DEBUG&#x3D;nuxt:* node --inspect node_modules&#x2F;nuxt&#x2F;bin&#x2F;nuxt&quot;,</span><br><span class="line">&quot;build&quot;: &quot;nuxt build --profile&quot;,</span><br><span class="line">&quot;start&quot;: &quot;cross-env NODE_ENV&#x3D;production node server&#x2F;index.js&quot;,</span><br></pre></td></tr></table></figure><h3 id="项目精简"><a href="#项目精简" class="headerlink" title="项目精简"></a>项目精简</h3><p>这个问题，仁者见仁。</p><p>大部分会遇到的应该都是按需加载，这个要挨个去试。</p><p>build 时候可以增加参数来触发 nuxt 提供的 analyze 功能(其实就是 webpack-bundle-analyzer，用过 webpack 的人都知道)</p><p>用我的命令就是<br><code>npm run build -- -a</code></p><p>剩下的看着来吧</p><h3 id="静态压缩"><a href="#静态压缩" class="headerlink" title="静态压缩"></a>静态压缩</h3><p>目前项目短期内没有使用 CDN 的打算，所以首屏加载速度的一个大头就要靠自己了。</p><p>直接使用 nuxt 的 render.compressor 只能做到首屏的 html 压缩，其余的 js 都是动态压缩，消耗过多的资源，所以打算像 SPA 那样，部署时直接放入 .gz 和 .br 文件，节约算力。但 nuxt 并没有这方面支持，所以只得靠 express 来直接返回资源。</p><p>整个改动分为两部分。1. build 时生成静态压缩文件; 2. 让 express 返回静态压缩文件</p><p>第一部分我编写了一个 middleware，代码贴在这里。实际上逻辑很简单，就是调用了 compression-webpack-plugin 生成 gzip，brotli-webpack-plugin 生成 brotli。</p><p><code>npm install -D brotli-webpack-plugin compression-webpack-plugin</code></p><p><code>/server/compressModule.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> CompressionPlugin;</span><br><span class="line"><span class="keyword">let</span> BrotliPlugin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gzip = &#123;</span><br><span class="line">  test: <span class="regexp">/\.(js|css|html|svg)$/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPlugin</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!CompressionPlugin) &#123;</span><br><span class="line">    CompressionPlugin = <span class="built_in">require</span>(<span class="string">&quot;compression-webpack-plugin&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!BrotliPlugin) &#123;</span><br><span class="line">    BrotliPlugin = <span class="built_in">require</span>(<span class="string">&quot;brotli-webpack-plugin&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compressionModule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.extendBuild(<span class="function">(<span class="params">config, &#123; isDev, isServer&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDev || isServer) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    getPlugin()</span><br><span class="line">    <span class="keyword">const</span> options = <span class="built_in">this</span>.options[<span class="string">&quot;nuxt-compress&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> gzipConfig = options ? &#123; ...gzip, ...options.gzip &#125; : gzip;</span><br><span class="line">    <span class="keyword">const</span> brotliConfig = options &amp;&amp; options.brotli ? options.brotli : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    config.plugins.push(</span><br><span class="line">      <span class="keyword">new</span> CompressionPlugin(gzipConfig),</span><br><span class="line">      <span class="keyword">new</span> BrotliPlugin(brotliConfig)</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = compressionModule;</span><br></pre></td></tr></table></figure><p>然后在 nuxt.config.js 中添加以下配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// version &lt; 2.9.0 使用 devModules 替换 buildModules</span></span><br><span class="line">  buildModules: [</span><br><span class="line">    <span class="string">&#x27;~~/server/compressModule&#x27;</span>,</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二部分要让 express 读取静态压缩文件，借助了 express-static-gzip 这个中间件。这个中间件做了比较完善的处理，放心使用</p><p>在 express 入口，注册这个中间件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载 static gzip br 并优先提供 brotli 压缩</span></span><br><span class="line">app.use(<span class="string">&quot;/_nuxt/&quot;</span>, expressStaticGzip(<span class="string">&#x27;./.nuxt/dist/client&#x27;</span>, &#123;</span><br><span class="line">  enableBrotli: <span class="literal">true</span>,</span><br><span class="line">  orderPreference: [<span class="string">&#x27;br&#x27;</span>]</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>该配置基于默认情况，build 后访问的 js 路径为 <code>example.com/_nuxt/xxxxxxxxxxxxxxx.js</code></p><h3 id="css-分离"><a href="#css-分离" class="headerlink" title="css 分离"></a>css 分离</h3><p>nuxt 提供了配置，直接使用即可实现大概的效果</p><p>build.extractCSS = true</p><p>如果要精确来，就自行研究吧，反正这个是实现我们想要的样子了</p><h2 id="其他-nuxt-js-的坑"><a href="#其他-nuxt-js-的坑" class="headerlink" title="其他 nuxt.js 的坑"></a>其他 nuxt.js 的坑</h2><ul><li><p>layout 如果在 <nuxt/> 下方有组件，会出现两次渲染的问题，这个问题我也解释不了，我是直接绕开了这个。有发生相同情况的小伙伴就去提 issue 吧</p></li><li><p>nuxt.js 选用了 axios，依赖为 <code>@nuxtjs/axios</code>，官网说不需要自行再引入 axios，但我这里不引入什么都干不了……<br>nuxt.config.js 中要加入 modules 配置，手脚架已经给出了配置<br>我们的业务会通过API封装执行 http，所以不需要进一步处理</p><p>服务端的 axios 不会自动携带 Cookie。如果想要优雅的解决，那就在 axios 封装那里新增一个接口来注入 Cookie，然后靠 router-middleware 从 context.headers.cookie 获取并注入</p></li><li><p>vuex 在服务端初始化，然后将数据递交给前端，不清楚客户端初始化时会不会再初始化插件</p></li><li><p>引入许多代码都会出现 unexpected identifier，可以在调用栈中看到是哪个 loader 加载哪个文件时发生的问题，调用栈可以看报错时的网页。<br>但并不好解决，一般时候都是因为组件注册，引入时调用了某些代码，目前的解法都是改为直接引用组件，让整条链路避开 Vue.use 和 Vue.component。</p></li><li><p>凡是动用 window 或 document 以及下设对象的代码，都要避免让服务端执行。</p></li><li><p>Vue.use() 有不少组件无法引入，解决方案为局部引入。但也有组件局部引入就无法工作，这时候可能就要全局引入。</p></li><li><p>目前有一个最坑的东西，not matching，服务端渲染结果与浏览器渲染结果不匹配。<br>开发环境会导致浏览器抛弃冲突的标签重新再渲染一次，并抛出警告；生产环境不会有处理。官方讲最常见的是 table 中的 tbody，实际场景中，服务端 render 和客户端 render 不匹配就会出现这个，比如客户端因为数据不同重新渲染的结果不一致<br>这个问题尽量避免，因为可能会出现因数据异常导致页面直接卡住(常见于 v-if 使用不当)</p></li><li><p>如果出现这个警告<br><code>WARN: Please use build.postcss in your nuxt.config.js instead of an external config file. Support for such files will be removed in Nuxt 3 as they remove all defaults set by Nuxt and can cause severe problems with features like alias resolving inside your CSS.</code></p><p>实际上是很小的事，就是告诉你 postcss 要配置到 nuxt.config.js 中了，把 postcss 的配置文件中所有内容配置到 build.postcss 中即可。</p></li></ul><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>关于这次迁移，满网搜索都是 nuxt 的 demo，就没有一个拿出点干货。</p><p>现在做技术，实在是有点太浮躁了，自以为写个 demo 就是会了一切。</p><p>其实整个迁移过程中，遇到的坑还有很多，但是有许多都是前端代码写的不够严谨，用法不规范导致，也不好意思拿出来。看到这篇文章的有缘人如果遇到什么问题无法解决，欢迎叨扰，或多或少我会帮得到您。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文章书写于 2019-09-06，改造是8月中旬，使用的 nuxt.js 版本为 2.8.1，后升级到2.9.0，文中可能包含两个版本的内容，区别不是太大，关于版本差距详见&lt;a href=&quot;https://github.com/nuxt/nuxt.js/releases&quot;&gt;</summary>
      
    
    
    
    <category term="前端" scheme="http://www.zzmark.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="http://www.zzmark.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue.js" scheme="http://www.zzmark.top/tags/Vue-js/"/>
    
    <category term="Nuxt.js" scheme="http://www.zzmark.top/tags/Nuxt-js/"/>
    
    <category term="SEO" scheme="http://www.zzmark.top/tags/SEO/"/>
    
    <category term="SSR" scheme="http://www.zzmark.top/tags/SSR/"/>
    
  </entry>
  
  <entry>
    <title>Java 获取客户端真实 IP</title>
    <link href="http://www.zzmark.top/2020/02/id_883234523/"/>
    <id>http://www.zzmark.top/2020/02/id_883234523/</id>
    <published>2020-02-22T13:28:59.000Z</published>
    <updated>2020-02-22T13:28:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>一般来讲，获取客户端 ip 很容易。但是现在的部署结构，服务端都是在各层反向代理之后，直接获取的 ip 都是反向代理的 ip。</p><p>现在，主流的做法有两种</p><h2 id="根正苗红的-RFC-7239-Forwarded"><a href="#根正苗红的-RFC-7239-Forwarded" class="headerlink" title="根正苗红的 RFC 7239 Forwarded"></a>根正苗红的 RFC 7239 Forwarded</h2><p>2014年 IETF 组织提出了 <code>[RFC 7239](https://tools.ietf.org/html/rfc7239)</code> 解决这一问题。</p><p>但这玩意太新了，目前 Java 阵营，没几个支持的……</p><p>这里有热心网友的统计<a href="https://c960657.github.io/forwarded.html">https://c960657.github.io/forwarded.html</a></p><p>就说 spring 一家，除 webflux 天生支持外，基于 servlet 的全都不认这东西。<br>也就是说，spring-mvc, springboot 等目前还不支持</p><p>不过有开源的 filter 提供了相应的支持代码，可以尝试一下，因为我没有测试过，这里并没有地址可贴，自行寻找。</p><p>大概看起来就是这样的<br><code>Forwarded: for=192.0.2.60; proto=http; by=203.0.113.43</code></p><p>可以参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Forwarded">Forwarded - HTTP | MDN</a></p><h2 id="社区方案-X-Forwarded"><a href="#社区方案-X-Forwarded" class="headerlink" title="社区方案 X-Forwarded-*"></a>社区方案 X-Forwarded-*</h2><p>为了解决这个问题，社区推出了一个方案，将各层反向代理的 ip 都写在祖传属性 http.Header: X-Forwarded-* 属性中</p><p>因为 RFC 7239 推广程度还不够乐观，所以，现阶段靠谱点的做法还是用这祖传的东西</p><p>Java 端用起来也很方便，这里提供两个推荐方案</p><ol><li><p>tomcat filter</p><p> tomcat 提供了一个 RemoteIpFilter 可以支持 X-Forwarded-* 的请求头部，自动根据这个修改 ServletRequest 中 getRemoteAddr 方法返回值，只需要启用该 filter 即可实现</p><p> 这个方法十分简单，spring boot / springMVC 均适用，强烈推荐。但局限于标准的 X-Forwarded-* 规则，所以有复杂需求的话，还是选择下面的方法吧</p></li><li><p>springboot + tomcat 适用</p><p> tomcat 在 springboot 中提供了以下配置，可以配置用于传输”x-forwarded”信息的headers名：</p><p> server.tomcat.remote-ip-header=x-your-remote-ip-header<br> server.tomcat.protocol-header=x-your-protocol-header</p></li></ol><p>什么？你说你用 Jetty？那可以试试这个 ForwardedRequestCustomizer，效果更好。</p><p>什么？你说你用睾贵的 Undertow？自己找吧，这东西我么用过。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一般来讲，获取客户端 ip 很容易。但是现在的部署结构，服务端都是在各层反向代理之后，直接获取的 ip 都是反向代理的 ip。&lt;/p&gt;
&lt;p&gt;现在，主流的做法有两种&lt;/p&gt;
&lt;h2 id=&quot;根正苗红的-RFC-7239-Forwarded&quot;&gt;&lt;a href=&quot;#根正苗红的-</summary>
      
    
    
    
    <category term="Java" scheme="http://www.zzmark.top/categories/Java/"/>
    
    
    <category term="Java" scheme="http://www.zzmark.top/tags/Java/"/>
    
    <category term="后端" scheme="http://www.zzmark.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="tomcat" scheme="http://www.zzmark.top/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>常用环境 mirror 地址</title>
    <link href="http://www.zzmark.top/2020/02/id_3755372975/"/>
    <id>http://www.zzmark.top/2020/02/id_3755372975/</id>
    <published>2020-02-22T13:25:29.000Z</published>
    <updated>2020-02-22T13:25:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要覆盖了我可能会去使用的 mirror。长期更新。</p><h2 id="前端-node-管理以及常用-mirror-地址"><a href="#前端-node-管理以及常用-mirror-地址" class="headerlink" title="前端 node 管理以及常用 mirror 地址"></a>前端 node 管理以及常用 mirror 地址</h2><p>总共分三个部分，nvm、npm、其他镜像</p><p>我选镜像的原则是，阿里、华为、清华，哪个好用就哪个</p><p>最近没有对 yarn 的使用，这部分暂且省略</p><h3 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a>nvm</h3><p>对于安装 node 环境，无论是 win/Linux，均推荐使用 nvm 安装环境，方便、稳妥、麻烦少</p><h3 id="目标环境"><a href="#目标环境" class="headerlink" title="目标环境"></a>目标环境</h3><ul><li>node LTS 版本</li><li>npm 而非 cnpm (个人不喜欢cnpm)</li><li>(可选) yarn 包管理工具</li><li>安装位置均为默认位置，对 C盘 有强迫症的，请自行前往 nvm项目页面 寻找定制路径的方案</li></ul><p>nvm 有两个版本，nvm-windows 和 nvm。</p><p>最近 nodejs.org 的 cdn 也很不错了，不设置 mirror 很多时候是能下载得动</p><p>nvm：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install nvm, 安装后记得重启终端让环境变量生效</span></span><br><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.1/install.sh | bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># nvm 不支持配置 mirror，但提供了环境变量来影响配置</span></span><br><span class="line"><span class="built_in">export</span> NVM_IOJS_ORG_MIRROR=https://npm.taobao.org/mirrors/iojs</span><br><span class="line"><span class="built_in">export</span> NVM_NODEJS_ORG_MIRROR=http://npm.taobao.org/mirrors/node</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下安装 lts 版本 node 命令</span></span><br><span class="line">nvm install --lts</span><br><span class="line">nvm use --lts</span><br></pre></td></tr></table></figure><p>nvm-windows:</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">REM nvm-windows 贴心的给我们提供了文档 https://github.com/coreybutler/nvm-windows#usage</span></span><br><span class="line">nvm node_mirror https://npm.taobao.org/mirrors/node/</span><br><span class="line">nvm npm_mirror https://npm.taobao.org/mirrors/npm/</span><br><span class="line"></span><br><span class="line">nvm list available</span><br><span class="line"></span><br><span class="line"><span class="comment">REM 安装版本需要自行填写</span></span><br><span class="line">nvm install <span class="variable">%VERSION%</span></span><br><span class="line">nvm use <span class="variable">%VERSION%</span></span><br></pre></td></tr></table></figure><h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 必备的、或许有用的、应该有用的，都在这了</span></span><br><span class="line">npm config <span class="built_in">set</span> registry=https://registry.npm.taobao.org/</span><br><span class="line">npm config <span class="built_in">set</span> electron-mirror=https://npm.taobao.org/mirrors/electron/</span><br><span class="line">npm config <span class="built_in">set</span> phantomjs_cdnurl=https://npm.taobao.org/mirrors/phantomjs/</span><br><span class="line">npm config <span class="built_in">set</span> chromedriver_cdnurl=http://npm.taobao.org/mirrors/chromedriver</span><br><span class="line">npm config <span class="built_in">set</span> sass-binary-site=https://npm.taobao.org/mirrors/node-sass/</span><br><span class="line">npm config <span class="built_in">set</span> SELENIUM_CDNURL=http://npm.taobao.org/mirrorss/selenium/</span><br><span class="line">npm config <span class="built_in">set</span> profiler_binary_host_mirror=http://npm.taobao.org/mirrors/node-inspector/</span><br></pre></td></tr></table></figure><h3 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yarn config <span class="built_in">set</span> registry http://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下未经测试</span></span><br><span class="line">yarn config <span class="built_in">set</span> electron-mirror=https://npm.taobao.org/mirrors/electron/</span><br><span class="line">yarn config <span class="built_in">set</span> phantomjs_cdnurl=https://npm.taobao.org/mirrors/phantomjs/</span><br><span class="line">yarn config <span class="built_in">set</span> chromedriver_cdnurl=http://npm.taobao.org/mirrors/chromedriver</span><br><span class="line">yarn config <span class="built_in">set</span> sass-binary-site=https://npm.taobao.org/mirrors/node-sass/</span><br><span class="line">yarn config <span class="built_in">set</span> SELENIUM_CDNURL=http://npm.taobao.org/mirrorss/selenium/</span><br><span class="line">yarn config <span class="built_in">set</span> profiler_binary_host_mirror=http://npm.taobao.org/mirrors/node-inspector/</span><br></pre></td></tr></table></figure><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>huaweicloud<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://mirrors.huaweicloud.com/repository/maven/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者使用这个</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o ~/.m2/settings.xml https://mirrors.huaweicloud.com/v1/configurations/maven?</span><br></pre></td></tr></table></figure><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o <span class="variable">%USERPROFILE%</span>/.m2/settings.xml https://mirrors.huaweicloud.com/v1/configurations/maven?</span><br></pre></td></tr></table></figure><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><h3 id="pip-pypi"><a href="#pip-pypi" class="headerlink" title="pip(pypi)"></a>pip(pypi)</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;主要覆盖了我可能会去使用的 mirror。长期更新。&lt;/p&gt;
&lt;h2 id=&quot;前端-node-管理以及常用-mirror-地址&quot;&gt;&lt;a href=&quot;#前端-node-管理以及常用-mirror-地址&quot; class=&quot;headerlink&quot; title=&quot;前端 node 管理</summary>
      
    
    
    
    <category term="环境" scheme="http://www.zzmark.top/categories/%E7%8E%AF%E5%A2%83/"/>
    
    
    <category term="环境" scheme="http://www.zzmark.top/tags/%E7%8E%AF%E5%A2%83/"/>
    
    <category term="tools" scheme="http://www.zzmark.top/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>VS Code 使用记录</title>
    <link href="http://www.zzmark.top/2020/02/vscode/"/>
    <id>http://www.zzmark.top/2020/02/vscode/</id>
    <published>2020-02-22T13:24:02.000Z</published>
    <updated>2020-02-22T13:24:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录个人使用 VS Code 时发现的易用插件、遇到的问题、解决方案。</p><p>长期更新</p><h2 id="配置、插件-同步插件-Settings-Sync"><a href="#配置、插件-同步插件-Settings-Sync" class="headerlink" title="配置、插件 同步插件 Settings Sync"></a>配置、插件 同步插件 Settings Sync</h2><p>最近发现了一个好东西，可以借助 github gist 给 vscode 提供一个配置同步，这款插件名为 <code>Settings Sync</code></p><p>使用十分方便，在新安装好的 vscode 上安装这款插件，登录 github 账号，并配置 gist 地址，就可以同步配置</p><h2 id="Markdown-转换为-PDF"><a href="#Markdown-转换为-PDF" class="headerlink" title="Markdown 转换为 PDF"></a>Markdown 转换为 PDF</h2><p>Markdown 转换为 PDF 的思路，是借助工具，转换为 html，然后通过浏览器的 <code>打印为 PDF</code> 生成 PDF 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">markdown -&gt; html -&gt; pdf</span><br></pre></td></tr></table></figure><p>方案可行，缺点是不灵活，虽然写成脚本也没差。</p><p>为此诞生了很多方便的工具</p><p>这里记录一款 vscode 的插件 <a href="https://marketplace.visualstudio.com/items?itemName=yzane.markdown-pdf">yzane/Markdown PDF</a> 扩展，可以很容易的将 markdown 转换为 PDF。</p><p>注意：这个工具依赖于 chromium，说白了就是要个浏览器。插件安装后会自动下载 Chromium，但是很慢，而且很大，如果电脑中有 Chrome，可以直接配置以下信息</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;markdown-pdf.executablePath&quot;: &quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe&quot;,</span><br></pre></td></tr></table></figure><p>让插件使用现有的浏览器，节约时间节约空间。</p><p>顺便还有一些我平常使用的配置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;markdown-pdf.styles&quot;: [</span><br><span class="line">    <span class="string">&quot;markdown-pdf.css&quot;</span></span><br><span class="line">],</span><br><span class="line">&quot;markdown-pdf.executablePath&quot;: &quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe&quot;,</span><br><span class="line">&quot;markdown-pdf.includeDefaultStyles&quot;: false,</span><br><span class="line">&quot;markdown-pdf.displayHeaderFooter&quot;: false,</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文记录个人使用 VS Code 时发现的易用插件、遇到的问题、解决方案。&lt;/p&gt;
&lt;p&gt;长期更新&lt;/p&gt;
&lt;h2 id=&quot;配置、插件-同步插件-Settings-Sync&quot;&gt;&lt;a href=&quot;#配置、插件-同步插件-Settings-Sync&quot; class=&quot;header</summary>
      
    
    
    
    <category term="环境" scheme="http://www.zzmark.top/categories/%E7%8E%AF%E5%A2%83/"/>
    
    
    <category term="环境" scheme="http://www.zzmark.top/tags/%E7%8E%AF%E5%A2%83/"/>
    
    <category term="vscode" scheme="http://www.zzmark.top/tags/vscode/"/>
    
    <category term="ide" scheme="http://www.zzmark.top/tags/ide/"/>
    
  </entry>
  
  <entry>
    <title>git 配置代理</title>
    <link href="http://www.zzmark.top/2020/02/git-proxy/"/>
    <id>http://www.zzmark.top/2020/02/git-proxy/</id>
    <published>2020-02-22T13:22:58.000Z</published>
    <updated>2020-02-22T13:22:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近有远程办公的需要，整理了一下如何通过代理使用git</p><ul><li>代理是通过 ssh 构建的 socks5 代理，http 还可以用 http 代理，但 ssh 不行，命令不兼容，我懒得去搞那么全</li><li>环境 windows，也会提供 linux/mac 的配置</li></ul><p>连接 git 的方式有两种，http 和 ssh，两种设置不同，所以分开说</p><h2 id="http-proxy"><a href="#http-proxy" class="headerlink" title="http.proxy"></a>http.proxy</h2><p>http 连接的代理不区分系统</p><p>git 的配置会写在 <code>%USERPROFILE%/.gitconfig</code> 文件中，命令设置后可以看一眼，很容易懂</p><p>如果连接 git 使用了 http 连接，则只需要 http.proxy 配置项即可，最简单粗暴的配置如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy socks5h://127.0.0.1:1080</span><br></pre></td></tr></table></figure><p>这样不优雅，git 提供了更精细的代理配置，可针对域名设置代理，例如单独为 github 配置代理：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.https://github.com.proxy socks5h://127.0.0.1:1080</span><br></pre></td></tr></table></figure><p>修改后，最好看一眼配置文件，明白这其中的细节和原理</p><h2 id="ssh-proxy"><a href="#ssh-proxy" class="headerlink" title="ssh  proxy"></a>ssh  proxy</h2><p>如果通过 ssh 连接，代理不归 git 管，而是要配置给 ssh。</p><p>这里需要区分系统</p><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p>windows 的 ssh 配置文件在 <code>%USERPROFILE%/.ssh/config</code> 文件中，如果不存在自行创建，记得删除后缀名。<br>搞不懂后缀名的人，可以通过这个命令来创建文件，记得删除文件中的内容</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> &quot;&quot; &gt;&gt; <span class="variable">%USERPROFILE%</span>/.ssh/config</span><br></pre></td></tr></table></figure><p>然后，举例说明，给 github.com 设置代理，配置文件的格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">    User git</span><br><span class="line">    ProxyCommand connect -S 127.0.0.1:1080 %h %p</span><br></pre></td></tr></table></figure><h3 id="linux-mac"><a href="#linux-mac" class="headerlink" title="linux/mac"></a>linux/mac</h3><p>linux 和 mac 系统，需要使用 nc 工具，请先确保有这个东西。</p><p>配置文件在 <code>~/.ssh/config</code>，可以用类似于 windows 的命令创建文件，不过更推荐直接用 vim 编辑</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.ssh/config</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">    User git</span><br><span class="line">    ProxyCommand nc -v -x 127.0.0.1:1080 %h %p</span><br></pre></td></tr></table></figure><h2 id="取消代理"><a href="#取消代理" class="headerlink" title="取消代理"></a>取消代理</h2><p>很容易的，直接到配置文件中删除掉相应的配置即可。</p><p>http 代理可以用以下命令抹除配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近有远程办公的需要，整理了一下如何通过代理使用git&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代理是通过 ssh 构建的 socks5 代理，http 还可以用 http 代理，但 ssh 不行，命令不兼容，我懒得去搞那么全&lt;/li&gt;
&lt;li&gt;环境 windows，也会提供 linux</summary>
      
    
    
    
    <category term="环境" scheme="http://www.zzmark.top/categories/%E7%8E%AF%E5%A2%83/"/>
    
    
    <category term="git" scheme="http://www.zzmark.top/tags/git/"/>
    
    <category term="环境" scheme="http://www.zzmark.top/tags/%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
  <entry>
    <title>arthas使用记录</title>
    <link href="http://www.zzmark.top/2018/12/jvm-arthas/"/>
    <id>http://www.zzmark.top/2018/12/jvm-arthas/</id>
    <published>2018-12-23T16:00:00.000Z</published>
    <updated>2018-12-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>前些日子遇到了一次线上问题，新部署的机器，还没有流量，浏览器页面第一次打开耗时极其过分(10s~40s)，机器没崩人先疯了。</p><p>几个命令下去，机器内存、cpu、IO 负载等参数表示机器很闲，所以怀疑是代码问题</p><p>浏览器 devTools 上显示请求耗时都在 <code>TTFB</code> 上</p><p>当时看着代码怀疑了一圈又一圈，尝试在本地 debug 复现，折腾了两个小时，复现失败。</p><p>然后尝试找某种监测方法调用的工具，搜到了几个不同种类的工具，btrace、jvm-sandbox、arthas、greys，这几个工具都十分的强大，不过最终我选用了arthas，当然理由很肤浅只是因为中文手册容易阅读（救场如救火）</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>实际上这篇文章，只是为了记录下排错的思路，具体的操作当时没有记录下来</p><p>这个工具能实现排查链路中每个调用的耗时情况，当然并没有递归(可能别的工具有)，所以只能定位过滤到的方法内的调用。</p><p>不过基于这点，就可以解决许多的问题了</p><p>好了，本文完结，下面的是我事后整理的过程。</p><blockquote><p>计算方法调用的耗时和链路上的耗时，使用trace命令加#cost筛选时间，这个命令可以打印出调用列表和每个方法调用的耗时<br>    定位到某个耗时很大的方法上，大概就达成80%了，毕竟这种原因不明的问题，找到问题比解决问题更难<br>    实际上我这次使用已经结束了，我监测的是入口，直接定位到了耗时极大的getSession()方法，然后怀疑是tomcat生成sessionId的时候调用的Random性能不足，替换为 /dev/./urandom 问题解决<br>    如果你发现这条链路上耗时极大的方法可能有多个调用来源，那就使用stack来抓取调用链，可以找到调用来源<br>    精确定位好后，用watch抓取方法入参和出参<br>    大概就这些了</p></blockquote><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>文章相当短，这工具我也只摸了皮毛（救场如救火）</p><p>只能说自己无知，有这方面经验的人直接就会想到用这类工具排查，不会绕这么大个弯子。这次经验也算是给自己增加了一种排错手段</p><p>至于当时遇到的问题到底是啥？</p><p>tomcat, 云服务器部署，默认使用了 <code>/dev/random</code>，云服务器可能没有做处理，熵池亏空，导致了在生成 session 这个步骤时产生了阻塞。<br>最终解决方法，已经时江湖广为流传的，<code>-Djava.security=file:/dev/./urandom</code></p><p>2019.01.04：<br>唯品会的白衣大大曾经还详细分析过这个问题，在这里贴上原文：<a href="http://calvin1978.blogcn.com/articles/securerandom.html">SecureRandom的江湖偏方与真实效果</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前些日子遇到了一次线上问题，新部署的机器，还没有流量，浏览器页面第一次打开耗时极其过分(10s~40s)，机器没崩人先疯了。&lt;/p&gt;
&lt;p&gt;几个命令下去，机器内存、cpu、IO 负载等参数表示机器很闲，所以怀疑是代码问题&lt;/p&gt;
&lt;p&gt;浏览器 devTools 上显示请求耗</summary>
      
    
    
    
    <category term="后端" scheme="http://www.zzmark.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="http://www.zzmark.top/tags/Java/"/>
    
    <category term="JVM" scheme="http://www.zzmark.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>博客更换至caddy</title>
    <link href="http://www.zzmark.top/2018/12/migration-to-caddy/"/>
    <id>http://www.zzmark.top/2018/12/migration-to-caddy/</id>
    <published>2018-12-23T16:00:00.000Z</published>
    <updated>2018-12-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近想要搞一个下载文件的页面，又不想自己写前端，nginx 的 autoindex 太难看，想要使用 fancyindex 却还需要编译 nginx 才能开启这功能，目前在 docker 上懒得自己搞，想起了 caddy 这个东西带这个功能并且还算看得过去，就有想法去搞 caddy。</p><h3 id="before"><a href="#before" class="headerlink" title="before"></a>before</h3><p>CentOS7 docker，nginx 使用了官方 docker 镜像</p><p>暴露80、443端口，挂载本地文件夹，网页内容放在本地，配置方面也只是设置了 <code>http -&gt; https</code>，还有 <code>TLS</code> 证书，证书使用 <code>Let&#39;s Encrypt</code> 通配符证书，开启 http2，算法方面该默认都默认没有什么特殊的</p><h3 id="after"><a href="#after" class="headerlink" title="after"></a>after</h3><p>CentOS7 docker，caddy 使用了 <a href="https://hub.docker.com/r/abiosoft/caddy">abiosoft/caddy</a></p><p>暴露80、443端口，挂载本地文件夹，使用 caddy/git 插件拉取 github 仓库内容，方便日后更换博客前端，也方便当前 hexo 内容同步，稍后把 github 的 homepage 改到自己的域名上</p><p>caddy 配置了自动的 TLS 证书，默认开启 http2 (不过在我浏览器上，http2并没有生效，SSLlabs倒是通过了，可能本地环境问题)，默认使用 TLS 1.2，想要使用 TLS 1.3 需要自行编译 golang 运行环境，想要启动 QUIC 需要手动加一个启动指令，不过这个 docker image 没提供这个，想搞就要自行 build 一个，或许过几天手痒痒就去搞起。</p><h3 id="赠品"><a href="#赠品" class="headerlink" title="赠品"></a>赠品</h3><p>caddy 的文档，建议去看官方文档，英文也没几个词翻翻字典就当学英语了</p><p><a href="https://caddyserver.com/docs">官方文档</a><br><a href="https://dengxiaolong.com/caddy/zh/">中文翻译文档-旧</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近想要搞一个下载文件的页面，又不想自己写前端，nginx 的 autoindex 太难看，想要使用 fancyindex 却还需要编译 nginx 才能开启这功能，目前在 docker 上懒得自己搞，想起了 caddy 这个东西带这个功能并且还算看得过去，就有想法去搞 c</summary>
      
    
    
    
    <category term="运维" scheme="http://www.zzmark.top/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="nginx" scheme="http://www.zzmark.top/tags/nginx/"/>
    
    <category term="caddy" scheme="http://www.zzmark.top/tags/caddy/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC @RestControllerAdvice遇到的坑</title>
    <link href="http://www.zzmark.top/2018/04/springmcv-advice/"/>
    <id>http://www.zzmark.top/2018/04/springmcv-advice/</id>
    <published>2018-04-26T16:00:00.000Z</published>
    <updated>2018-04-26T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实也说不上是坑，最近在配置框架时使用到了这个注解来最终错误处理</p><p>但是配置过程中发现了这个注解的问题</p><p>先说说场景，目前有两个标注 <code>@RestControllerAdvice</code> 的类，类和类下面注册的异常分别是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GlobalExceptionAdvice:</span><br><span class="line">|-Exception</span><br><span class="line">AppExceptionAdvice:</span><br><span class="line">|-OtherException</span><br></pre></td></tr></table></figure><p>实际已注册异常比这要多。这时触发 <code>OtherException</code> ，发现响应错误的是 <code>Exception</code> 的 handler</p><p>也就是说， <code>OtherException</code> 的 handler 失效了</p><p>最初怀疑是注解扫描没有扫描到 AppExceptionAdvice，给 bean 的 Construct 里打印日志，证明了 bean 被初始化</p><p>也就是说，明明被扫描了AppExceptionAdvice，却一点也没起作用。</p><p>不过在日志中看到了如下两条日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">18:43:27.352  INFO -- [on(2)-127.0.0.1] .m.m.a.ExceptionHandlerExceptionResolver : Detected @ExceptionHandler methods in globalExceptionAdvice</span><br><span class="line">18:43:27.353  INFO -- [on(2)-127.0.0.1] .m.m.a.ExceptionHandlerExceptionResolver : Detected @ExceptionHandler methods in appExceptionAdvice</span><br></pre></td></tr></table></figure><p>考虑可能性，一个覆盖了另一个，或者说先注册的占据了先机，判断异常时产生了这个情况。</p><p>打开 debug，抛出错误，在 <code>Exception</code> 的 handler 中抓取，查看调用栈，找到了 <code>ExceptionHandlerExceptionResolver.doResolveHandlerMethodException()</code> 方法，调用 handler 的方法就是这个。</p><p>以下代码基于 SpringMVC 4.3.11.RELEASE</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Find an &#123;<span class="doctag">@code</span> <span class="doctag">@ExceptionHandler</span>&#125; method and invoke it to handle the raised exception.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">doResolveHandlerMethodException</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">        HttpServletResponse response, HandlerMethod handlerMethod, Exception exception)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// getExceptionHandlerMethod 负责找到处理异常的Handler</span></span><br><span class="line">    ServletInvocableHandlerMethod exceptionHandlerMethod = getExceptionHandlerMethod(handlerMethod, exception);</span><br><span class="line">    <span class="keyword">if</span> (exceptionHandlerMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    exceptionHandlerMethod.setHandlerMethodArgumentResolvers(<span class="keyword">this</span>.argumentResolvers);</span><br><span class="line">    exceptionHandlerMethod.setHandlerMethodReturnValueHandlers(<span class="keyword">this</span>.returnValueHandlers);</span><br><span class="line">    ServletWebRequest webRequest = <span class="keyword">new</span> ServletWebRequest(request, response);</span><br><span class="line">    ModelAndViewContainer mavContainer = <span class="keyword">new</span> ModelAndViewContainer();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 负责执行handler</span></span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Invoking @ExceptionHandler method: &quot;</span> + exceptionHandlerMethod);</span><br><span class="line">        &#125;</span><br><span class="line">        Throwable cause = exception.getCause();</span><br><span class="line">        <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Expose cause as provided argument as well</span></span><br><span class="line">            exceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, exception, cause, handlerMethod);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Otherwise, just the given exception as-is</span></span><br><span class="line">            exceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, exception, handlerMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// other code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ExceptionHandlerExceptionResolver.doResolveHandlerMethodException() -&gt; getExceptionHandlerMethod()</p><p>下面这段代码用于寻找可适配当前 Exception 的 Method，由 LinkedHashMap 存放，这里就和顺序有关联了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的 exceptionHandlerAdviceCache 是个 LinkedHashMap，存放了已注册的 Advice 类和一个 Cache，Cache 不是分析目的</span></span><br><span class="line"><span class="keyword">for</span> (Entry&lt;ControllerAdviceBean, ExceptionHandlerMethodResolver&gt; entry : <span class="keyword">this</span>.exceptionHandlerAdviceCache.entrySet()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.getKey().isApplicableToBeanType(handlerType)) &#123;</span><br><span class="line">        ExceptionHandlerMethodResolver resolver = entry.getValue();</span><br><span class="line">        Method method = resolver.resolveMethod(exception);</span><br><span class="line">        <span class="keyword">if</span> (method != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ServletInvocableHandlerMethod(entry.getKey().resolveBean(), method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确定了顺序相关，就要考虑顺序是如何确定的。<br>实际上这时已经可以考虑到使用 @Order 来解决问题</p><p>继续追查代码，顺着resolver.resolverMethod() -&gt; resolveMethodByExceptionType() -&gt; getMappedMethod() 方法，我们可以找到如何将当前异常对应到具体方法的代码逻辑，这个方法在ExceptionHandlerMethodResolver 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the &#123;<span class="doctag">@link</span> Method&#125; mapped to the given exception type, or &#123;<span class="doctag">@code</span> null&#125; if none.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Method <span class="title">getMappedMethod</span><span class="params">(Class&lt;? extends Throwable&gt; exceptionType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 传入参数为当前错误，</span></span><br><span class="line">    List&lt;Class&lt;? extends Throwable&gt;&gt; matches = <span class="keyword">new</span> ArrayList&lt;Class&lt;? extends Throwable&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;? extends Throwable&gt; mappedException : <span class="keyword">this</span>.mappedMethods.keySet()) &#123;</span><br><span class="line">        <span class="comment">// this.mappedMethods 中存放了当前handler中的所有方法</span></span><br><span class="line">        <span class="keyword">if</span> (mappedException.isAssignableFrom(exceptionType)) &#123;</span><br><span class="line">            <span class="comment">// if条件会选出处理与入参类相同或为超集的类的方法，List存放结果</span></span><br><span class="line">            matches.add(mappedException);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!matches.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 将结果进行排序，并返回第一条结果对应的方法</span></span><br><span class="line">        Collections.sort(matches, <span class="keyword">new</span> ExceptionDepthComparator(exceptionType));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.mappedMethods.get(matches.get(<span class="number">0</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了这里，大概的性质就摸清楚了</p><p>总的来说，就是从 getExceptionHandlerMethod() 方法选出一个 handler，然后再这个 handler 内选出 method 用来处理这个异常。</p><p>这样就会造成一个问题，即排位靠前的 handler 内若是有这个异常的超集，那就轮不到排位靠后的 handler，导致了我所遇到的问题。</p><p>从现象看本质，再从本质制定规范。</p><ol><li>如果要使用多个 handler，就像我这里有一个 globalExceptionHandler，那就要使用 Order 手动控制扫描顺序，默认情况下 Advice 注解的 Order 为最低优先，大部分的 bean 都是这样。<br> 因为 globalExceptionHandler 优先级已经是最低了，我们只能去提高业务层 handler 的优先值。</li><li>同一个异常线，必须在同一个handler中，不然会出现被超集适配走的情况</li><li>或者干脆放弃使用 globalExceptionHandler 这个方案做兜底的异常处理，改为定制 springmvc 返回异常的处理器，这样对业务入侵为0</li></ol><p>剩下看个人吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;其实也说不上是坑，最近在配置框架时使用到了这个注解来最终错误处理&lt;/p&gt;
&lt;p&gt;但是配置过程中发现了这个注解的问题&lt;/p&gt;
&lt;p&gt;先说说场景，目前有两个标注 &lt;code&gt;@RestControllerAdvice&lt;/code&gt; 的类，类和类下面注册的异常分别是：&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="后端" scheme="http://www.zzmark.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="http://www.zzmark.top/tags/Java/"/>
    
    <category term="spring" scheme="http://www.zzmark.top/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>迁移到 Mac</title>
    <link href="http://www.zzmark.top/2018/04/transfer-to-macos/"/>
    <id>http://www.zzmark.top/2018/04/transfer-to-macos/</id>
    <published>2018-04-10T16:00:00.000Z</published>
    <updated>2018-04-10T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近重新搬出了黑苹果，打算把工作环境迁上去。</p><p>有些东西还是挺麻烦的，本想直接安装 docker 解决一些环境问题，后来觉得这玩意，笔记本内存并不大，也就只能拿来启动个 mysql，放弃了 docker</p><h2 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a><a href="https://brew.sh/">Homebrew</a></h2><p>Mac 系统中的 apt、yum，感觉应该是个十分方便的东西。可是实装后，我用来装了个 node，就出了许多问题</p><ol><li>node 装好后没有 npm，不晓得是不是我版本的问题</li><li>不能很好的定制版本，至少没有让我这个没接触过的很容易的选择版本</li><li>软链接还出了问题，虽然提供了解决方法，但是你都提供方法了为啥不自己修复一下</li></ol><p>总而言之，体验不好，最后node环境还是手工解决的，LTS版本</p><p>本想用来装个Java，然后发现里面并没有Oracle jdk，emmm……</p><p>到最后还是自行下载了pkg版本，虽然确实想试试 openjdk 来着</p><p>不了解Mac的服务管理，最后选择了手动下载二进制MySQL</p><h2 id="iTerm2-Oh-My-ZSH"><a href="#iTerm2-Oh-My-ZSH" class="headerlink" title="iTerm2 + Oh My ZSH"></a>iTerm2 + <a href="https://ohmyz.sh/">Oh My ZSH</a></h2><p>这个组合是一个产品小哥和数据大佬的推荐，Oh My ZSH实装之后觉得，zsh可定制性和各种插件好评，虽然我也用不上什么，不过tab的提示和自带主题真的可以</p><p>然而iTerm2就只能说一般了，没感觉到那种眼前一亮，跟系统自带的相比功能也好强度也好，也就那样，可能我还是用不到那些高大上的功能。</p><h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><ul><li><p><a href="https://www.jetbrains.com/">IntelliJ IDEA Ultimate</a><br>直接用 Jetbrains toolbox 安装，省时省力，还有中国 CDN，就是速度很看人品，太慢的话暂停重开可能就会好</p></li><li><p><a href="https://code.visualstudio.com/">VSCode</a><br>微软爸爸的记事本，轻量级开发 IDE，插件很多，底层据说是 Atom 魔改过的，不过那跟我没啥关系</p></li><li><p>印象笔记<br>安卓、win、mac 三平台同步，虽然最近没写过什么正经笔记</p></li><li><p><a href="https://www.google.cn/chrome/">Chrome</a><br>重度谷歌用户必须要有的东西，安卓、win、mac 三平台同步，什么都方便<br>如今也能在国内直接下载了</p></li><li><p>SS<br>用谷歌的怎么能没有这个，顺便一提最近打算自己架设线路，如有定时的轻度用户欢迎合作</p></li><li><p>微信、QQ<br>必须要有的聊天工具，不然自己就像与世隔绝了一样</p></li><li><p><a href="https://macdown.uranusjr.com/">MacDown</a><br>Mac 系统上的 markdown 编辑器，在我心中他只是第二，mou 还是比这个好用，可惜 mou 只支持到10.11<br>不过最近也很少用这东西，反而是 VSCode 一步到位了</p></li><li><p><a href="https://www.alfredapp.com/">Alfred</a><br>Mac 上的神器，能设置许多的方便功能，强于 Mac 的 Spotlight。我加装了有道插件、几个快捷启动、颜色编码识别插件。不过收费产品，暂时还没宽裕到支持正版，请允许我厚颜无耻一次。<br>win 上的 Wox 就是参照这个软件的模式做的。</p></li><li><p><a href="https://www.office.com/?auth=2">office</a><br>office365 套件，跟 win 上用的同一套，一个账户直接通用</p></li></ul><h2 id="朋友推荐的东西"><a href="#朋友推荐的东西" class="headerlink" title="朋友推荐的东西"></a>朋友推荐的东西</h2><p>这里的东西我并没有使用</p><ul><li><p><a href="http://happenapps.com/">Quiver</a><br>用于代替印象笔记，markdown编写，笔记该有的他都有，是个中国人开发的有GitHub仓库不过没开源，收费软件，再加上没有印象那么强劲的全平台，而且我印象会员还有很久，就没考虑</p></li><li><p>MWeb<br>比上面那个更强的笔记软件，markdown编写，还支持生成hexo博客，IOS和Mac客户端，也是中国人开发的，看着官网感觉不错，可是理由同上。</p><p>如有其他日后补充。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近重新搬出了黑苹果，打算把工作环境迁上去。&lt;/p&gt;
&lt;p&gt;有些东西还是挺麻烦的，本想直接安装 docker 解决一些环境问题，后来觉得这玩意，笔记本内存并不大，也就只能拿来启动个 mysql，放弃了 docker&lt;/p&gt;
&lt;h2 id=&quot;Homebrew&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="环境" scheme="http://www.zzmark.top/categories/%E7%8E%AF%E5%A2%83/"/>
    
    
    <category term="环境" scheme="http://www.zzmark.top/tags/%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
</feed>
