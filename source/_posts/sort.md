---
title: 排序备忘
date: 2017-08-22 00:00:00
tags: 
 - Java
categories:
 - 后端
---

对前阵子玩的排序做了一下总结，目前已总结了 `冒泡排序` `选择排序` `快速排序`，堆排序和归并排序目前还没有吃透，桶排序写出来效率感人，也试过多线程的排序发现效率十分感人，就不拿出来献丑了

### 冒泡排序

最简单的排序算法，重复走访所以要排序的元素，每次比较两个相邻元素，如果顺序错误则调换。这个算法两端的极值会逐渐“浮”到应到的位置，所以起名冒泡排序。

过程如下：
  - 比较相邻元素，若顺序不符则调换
  - 对每一个元素执行这个过程

代码如下：
```java
for (int j = 0; j < arr.length - 1; j++) {
    for (int i = 0; i < arr.length - 1; i++) {
        if (arr[i] < arr[i + 1]) {
            int temp = arr[i + 1];
            arr[i + 1] = arr[i];
            arr[i] = temp;
        }
    }
}
```

### 选择排序

对冒泡排序的一个改进版本，每次遍历选出最小值/最大值，在本次遍历结束时放置到应摆放位置，效率高于冒泡排序。

过程如下：
  - 遍历，选出最小值/最大值
  - 将最小值/最大值放置在已排序区

代码如下
```java
for (int i = 0; i < arr.length; i++) {
    int min = i;
    for (int j = i + 1; j < arr.length; j++) {
        if (arr[min] > arr[j]) {
            min = j;
        }
    }
    int temp = arr[min];
    arr[min] = arr[i];
    arr[i] = temp;
}
```

### 快速排序

利用分治思想，对冒泡排序进行改进。
选出一个轴点，对待排序区进行遍历，遍历结束保证轴点左方均小于等于轴点，右方均大于轴点，然后依照轴点进行分治。效率理论上远远超过冒泡和选择。
该排序为不稳定排序，适合于数量较大、重复较少的情况

目前对快速排序的理解只能止步于这个层面，看了很多网上的代码，也没能再一步改良这个。

过程如下：
分治开始
  1. 选出轴点（一般为待排序区第一个）
  2. 遍历待排序区
      若该值小于轴点，则将该值放入小于轴点的区域
      若该值大于轴点，则将该值放入大于轴点的区域
  3. 将轴点放在小于轴点区和大于轴点区之间
  4. 依照轴点前后，分治（一般为递归法）

自己写的代码：
```java
/**
 * 快速排序
 *
 * @param i     待排序数组
 * @param start 待排序区域起点
 * @param end   待排序区域终点
 */
private static void quickSort(int[] i, int start, int end) {
    // 节省运行次数，但会带来一个缺点，待排序区只有两个数值时，排序不会执行,
    if (start + 1 < end) {
        // 边界点 = 轴点 + 1,
        int mid = start + 1;
        // 遍历,
        for (int t = start + 1; t < end; t++) {
            // 小于轴点，边界点后移，将值归入界点范围,
            if (i[start] > i[t]) {
                if (t > mid) {
                    int tmp = i[t];
                    i[t] = i[mid];
                    i[mid] = tmp;
                }
                mid += 1;
            // 大于轴点，将该值移动到界点后,
            } else {
                if (t > mid) {
                    int tmp = i[t];
                    i[t] = i[mid];
                    i[mid] = tmp;
                }
            }
        }
        // 将轴点放在两个区域中间，对换轴点和边界点,
        int t = i[start];
        i[start] = i[mid - 1];
        i[mid - 1] = t;
        // 分治,
        quickSort(i, start, mid - 1);
        quickSort(i, mid, end);
    }
}
```
